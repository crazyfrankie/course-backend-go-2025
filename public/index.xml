<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go 后端开发教程</title><link>https://example.org/</link><description>Recent content on Go 后端开发教程</description><generator>Hugo</generator><language>zh-cn</language><atom:link href="https://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>从 0 开始学 Go</title><link>https://example.org/docs/lesson00/%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E5%AD%A6-go/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson00/%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E5%AD%A6-go/</guid><description>&lt;h1 id="从-0-开始学-go">从 0 开始学 Go&lt;/h1>
&lt;p>接下来我会教大家如何成为一个入门级别的 Go 软件工程师，这个教程里面不会包含如何敲代码，但是包括了一些软件工程师的基本素养（很多都是代代相传的&lt;/p>
&lt;p>因为是面向 0 基础写的教程，所以很多地方比如说安装软件我会写的很细，以后的课程中可能就不会有这么细了&lt;/p>
&lt;p>不论你是否有基础相信都能有所收获&lt;/p>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>如果你想问我想学好互联网开发，当一个成功的码农最重要的是什么&lt;/p>
&lt;p>我觉得首先很重要的是&lt;strong>探索精神&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>好奇心：探索精神源于好奇心，即对世界和知识的渴望。好奇心驱使人们主动寻求新的经验、知识和理解，不满足于现有的答案和常规的思维模式。它激发人们对问题的提出、现象的解释和现实的改变。&lt;/li>
&lt;li>探索未知：探索精神鼓励人们主动面对未知领域和挑战。它推动人们跨越舒适区，积极探索新的领域、新的观点和新的经验。探索者愿意接受风险和不确定性，勇于面对失败和困难，以获取新的知识和发现。&lt;/li>
&lt;li>创新思维：探索精神促使人们采用创新的思维方式来解决问题和应对挑战。它鼓励人们打破传统的思维模式，尝试新的方法和观点，挖掘新的可能性。创新思维涉及跳出传统边界、建立连接和寻找新的解决方案。&lt;/li>
&lt;li>持续学习：探索精神与持续学习密切相关。探索者认识到知识和经验的不断积累对于个人成长和发展的重要性。他们愿意持续学习新的技能、学科和领域，并将学习应用于实践中，以推动个人和社会的进步。&lt;/li>
&lt;/ol>
&lt;p>是不是想起了玩游戏🎮时的经历？ YES！你完全可以带入到开发学习中&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;程序员贪婪又懒惰&amp;rdquo;——《Unix编程艺术》（The Art of Unix Programming）&lt;/p>&lt;/blockquote>
&lt;p>然后最重要的是 &lt;strong>坚持&lt;/strong> ✊&lt;/p>
&lt;p>还记得每次上课都听的迷迷糊糊的，这里为什么会报错？并发为什么每次效果不一样？&lt;code>interface&lt;/code> 有什么用？&lt;code>Context.context&lt;/code>是干啥的？为什么一开始要写个 &lt;code>r.Register()&lt;/code>?会在学习的过程中遇到数不清的问题，跳进数不清的坑。但是只要坚持你回过来看发现其实都很简单，每个大佬也都是从 rookie 开始的嘛&lt;/p>
&lt;p>碰到问题不可怕，找到解决问题的方式是关键，于是就引入了下一小节——&lt;strong>提问的智慧&lt;/strong>&lt;/p>
&lt;h2 id="提问的智慧">提问的智慧&lt;/h2>
&lt;p>详见 &lt;a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>直接引用 21 级学长写的文档 🙏&lt;/p>&lt;/blockquote>
&lt;p>你们或许在提问题的时候觉得我们很傲慢？&lt;/p>
&lt;h3 id="问题">🐂🐎问题&lt;/h3>
&lt;ul>
&lt;li>手机拍代码&lt;/li>
&lt;li>只说一个笼统的问题，不说细节&lt;/li>
&lt;li>夺命连环问&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://example.org/images/lesson00/1.png" alt="img">&lt;/p>
&lt;p>&lt;a href="https://github.com/LanshanTeam/Courseware-Backend-Go-2022/blob/main/class00-%E9%80%9A%E8%AF%86%E8%AF%BE/image/a277d2d2f89d0a22f4b12e425b585b2fcf547ede587345840.jpg">&lt;img src="https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class00-%E9%80%9A%E8%AF%86%E8%AF%BE/image/a277d2d2f89d0a22f4b12e425b585b2fcf547ede587345840.jpg" alt="a277d2d2f89d0a22f4b12e425b585b2fcf547ede587345840">&lt;/a>&lt;/p>
&lt;h3 id="例子">例子&lt;/h3>
&lt;p>&lt;strong>你以为的傲慢&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>学弟：学长我vscode装不上了怎么办？&lt;/li>
&lt;li>学长：你到官网下载安装包下载完双击它，一直点下一步就安装好了&lt;/li>
&lt;li>学弟：官网是什么&lt;/li>
&lt;li>学长：https://code.visualstudio.com/&lt;/li>
&lt;li>学弟：下载按钮在哪？&lt;/li>
&lt;li>学长：（截图）&lt;/li>
&lt;li>学弟：好了，下载到了，然后呢？&lt;/li>
&lt;li>学长：这个都不会还是别学了&lt;/li>
&lt;li>学弟：（感觉学长很傲慢）&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>实际上的傲慢：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>学弟：学长我的电脑是64位的windows 10，我在vscode官网下载 了对应版本，在我安装过程中出现了这个问题，使用百度搜索后还是没有办法解决，你能帮我看看吗？谢谢。（同时&lt;/li>
&lt;li>贴上安装失败的图片）&lt;/li>
&lt;li>学长：这个都不会还是别学了&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class00-%E9%80%9A%E8%AF%86%E8%AF%BE/image/image-20221030123200419.png" alt="img">&lt;/p>
&lt;p>&lt;strong>再举个🌰&lt;/strong>&lt;/p>
&lt;p>某论坛&lt;/p>
&lt;ul>
&lt;li>A：有人有赛博朋克2077游戏资源吗？&lt;/li>
&lt;li>B：有，给https://pan.baidu.com/xxxxxxxxxx&lt;/li>
&lt;li>A：为啥要用百度网盘啊，我没用过&lt;/li>
&lt;li>B：只有这个&lt;/li>
&lt;li>A：点击哪里下载啊&lt;/li>
&lt;li>B：（截了个图）&lt;/li>
&lt;li>A：哦哦&lt;/li>
&lt;li>过了几个小时&lt;/li>
&lt;li>A：为什么下下来不能直接玩？&lt;/li>
&lt;li>B：这是个压缩包，你要解压&lt;/li>
&lt;li>A：唉，我玩个游戏也太麻烦了，有什么方式能解压吗&lt;/li>
&lt;/ul>
&lt;p>是不是能理解了呢😄&lt;/p></description></item><item><title>基础语法</title><link>https://example.org/docs/lesson01/%E8%93%9D%E5%B1%B1%E5%B7%A5%E4%BD%9C%E5%AE%A4golang%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson01/%E8%93%9D%E5%B1%B1%E5%B7%A5%E4%BD%9C%E5%AE%A4golang%E7%AC%AC%E4%B8%80%E8%8A%82%E8%AF%BE/</guid><description>&lt;h1 id="蓝山工作室golang第一节课">蓝山工作室——Golang第一节课&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>首先，我要热烈欢迎你们加入我们的Go语言课程。Go语言是一门强大且灵活的编程语言，它具备高性能、简单易学的特点，已经在许多领域取得了广泛的应用。本课程将帮助你掌握Go语言的核心概念、语法和最佳实践，无论你是初学者还是有一些编程经验的学员。&lt;/p>
&lt;p>Go语言是一门开源编程语言，由Google开发并维护。它的设计目标是简单性、效率和可读性，使得开发者可以更轻松地构建高性能的应用程序。Go语言在云计算、网络编程、大数据处理等领域表现出色，是许多知名公司和大厂的首选语言之一。&lt;/p>
&lt;p>这节课的主要内容是认识：变量，常量，基本数据类型，运算符，流程控制，函数基础，fmt包&lt;/p>
&lt;h2 id="基础语法">基础语法&lt;/h2>
&lt;h3 id="var">var&lt;/h3>
&lt;h4 id="变量">变量&lt;/h4>
&lt;h5 id="变量类型">变量类型&lt;/h5>
&lt;p>变量（Variable）的功能是存储数据。不同的变量保存的数据类型可能会不一样。经过半个多世纪的发展，编程语言已经基本形成了一套固定的类型，常见变量的数据类型有：整型、浮点型、布尔型等。&lt;/p>
&lt;p>Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>整数类型（Integer Types）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>int&lt;/code>：根据你的操作系统架构，可以是32位或64位的整数。&lt;/li>
&lt;li>&lt;code>int8&lt;/code>、&lt;code>int16&lt;/code>、&lt;code>int32&lt;/code>、&lt;code>int64&lt;/code>：有符号整数类型，分别表示8位、16位、32位和64位整数。&lt;/li>
&lt;li>&lt;code>uint&lt;/code>：无符号整数类型，根据操作系统架构，可以是32位或64位。&lt;/li>
&lt;li>&lt;code>uint8&lt;/code>、&lt;code>uint16&lt;/code>、&lt;code>uint32&lt;/code>、&lt;code>uint64&lt;/code>：无符号整数类型，分别表示8位、16位、32位和64位整数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>浮点数类型（Floating-Point Types）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>float32&lt;/code>：单精度浮点数。&lt;/li>
&lt;li>&lt;code>float64&lt;/code>：双精度浮点数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>复数类型（Complex Types）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>complex64&lt;/code>：包含32位实部和32位虚部的复数。&lt;/li>
&lt;li>&lt;code>complex128&lt;/code>：包含64位实部和64位虚部的复数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>布尔类型（Boolean Type）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>bool&lt;/code>：表示真（true）或假（false）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>字符串类型（String Type）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>string&lt;/code>：用于存储文本数据的字符序列。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>字节类型（Byte Type）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>byte&lt;/code>：&lt;code>uint8&lt;/code> 的别名，通常用于表示ASCII字符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>符文类型（Rune Type）&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>rune&lt;/code>：&lt;code>int32&lt;/code> 的别名，通常用于表示&lt;strong>Unicode字符&lt;/strong>。&lt;/li>
&lt;li>Unicode（统一码、万国码、单一码）是一种字符编码标准，它用于表示世界上几乎所有的书写系统中的字符，&lt;strong>包括各种文字、标点符号和特殊符号&lt;/strong>。Unicode的目标是提供一个统一的、跨语言的字符编码系统，以消除不同字符编码之间的混乱和兼容性问题。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h5 id="变量声明">变量声明&lt;/h5>
&lt;p>Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。并且Go语言的变量声明后&lt;strong>必须使用&lt;/strong>。&lt;/p>
&lt;h5 id="变量的初始化">变量的初始化&lt;/h5>
&lt;p>Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为0。 字符串变量的默认值为空字符串。 布尔型变量默认为false。 切片、函数、指针变量的默认为nil。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span> &lt;span style="color:#1f2328">变量名&lt;/span> &lt;span style="color:#1f2328">类型&lt;/span> &lt;span style="color:#1f2328">=&lt;/span> &lt;span style="color:#1f2328">表达式&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span> &lt;span style="color:#1f2328">a&lt;/span> &lt;span style="color:#1f2328">=&lt;/span> &lt;span style="color:#0a3069">&amp;#34;initial&amp;#34;&lt;/span> &lt;span style="color:#57606a">// 类型推导，不指定类型自动判断&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span> &lt;span style="color:#1f2328">b&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">c&lt;/span> &lt;span style="color:#cf222e">int&lt;/span> &lt;span style="color:#1f2328">=&lt;/span> &lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">2&lt;/span> &lt;span style="color:#57606a">// 一次初始化多个变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span> &lt;span style="color:#1f2328">d&lt;/span> &lt;span style="color:#1f2328">=&lt;/span> &lt;span style="color:#cf222e">true&lt;/span> &lt;span style="color:#57606a">// 布尔型变量&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span> &lt;span style="color:#1f2328">e&lt;/span> &lt;span style="color:#cf222e">float64&lt;/span> &lt;span style="color:#57606a">// 普通声明未赋值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1f2328">f&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#6639ba">float32&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">e&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#57606a">// 类型转换初始化赋值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1f2328">g&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">a&lt;/span> &lt;span style="color:#0550ae">+&lt;/span> &lt;span style="color:#0a3069">&amp;#34;apple&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1f2328">fmt&lt;/span>&lt;span style="color:#1f2328">.&lt;/span>&lt;span style="color:#6639ba">Println&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">a&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">b&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">c&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">d&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">e&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">f&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#57606a">// initial 1 2 true 0 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1f2328">fmt&lt;/span>&lt;span style="color:#1f2328">.&lt;/span>&lt;span style="color:#6639ba">Println&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">g&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#57606a">// initialapple&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="常量">常量&lt;/h4>
&lt;p>相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 常量的声明和变量声明非常类似，只是把var换成了const，常量在定义的时候必须赋值。&lt;/p></description></item><item><title>数组和切片</title><link>https://example.org/docs/lesson02/02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson02/02/</guid><description>&lt;h1 id="第二节课">第二节课&lt;/h1>
&lt;h2 id="数组-array">数组-array&lt;/h2>
&lt;blockquote>
&lt;p>数组是指一系列同一类型数据的集合。数组中包含的每个数据被称为数组元素（element），一个数组包含的元素个数被称为数组的长度。&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>初始化&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#57606a">// var arr [len]type&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#57606a">// arr := [len]type{data1,data2}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">a&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">3&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">}&lt;/span> &lt;span style="color:#57606a">// 未初始化元素值为 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">b&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">...&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">3&lt;/span>&lt;span style="color:#1f2328">}&lt;/span> &lt;span style="color:#57606a">// 通过初始化值确定数组长度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">c&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">5&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#0550ae">100&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">4&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#0550ae">200&lt;/span>&lt;span style="color:#1f2328">}&lt;/span> &lt;span style="color:#57606a">// 通过索引号初始化元素，未初始化元素值为 0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">fmt&lt;/span>&lt;span style="color:#1f2328">.&lt;/span>&lt;span style="color:#6639ba">Println&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">a&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">b&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">c&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#57606a">//[1 2 0] [1 2 3] [0 0 100 0 200]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#57606a">//支持多维数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">d&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">4&lt;/span>&lt;span style="color:#1f2328">][&lt;/span>&lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{{&lt;/span>&lt;span style="color:#0550ae">10&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">11&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">20&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">21&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">30&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">31&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">40&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">41&lt;/span>&lt;span style="color:#1f2328">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">e&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">...&lt;/span>&lt;span style="color:#1f2328">][&lt;/span>&lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{{&lt;/span>&lt;span style="color:#0550ae">10&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">11&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">20&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">21&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">30&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">31&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">40&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">41&lt;/span>&lt;span style="color:#1f2328">}}&lt;/span> &lt;span style="color:#57606a">//第二维不能写&amp;#34;...&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">f&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">4&lt;/span>&lt;span style="color:#1f2328">][&lt;/span>&lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">20&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">21&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#0550ae">3&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">40&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#0550ae">41&lt;/span>&lt;span style="color:#1f2328">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">g&lt;/span> &lt;span style="color:#0550ae">:=&lt;/span> &lt;span style="color:#1f2328">[&lt;/span>&lt;span style="color:#0550ae">4&lt;/span>&lt;span style="color:#1f2328">][&lt;/span>&lt;span style="color:#0550ae">2&lt;/span>&lt;span style="color:#1f2328">]&lt;/span>&lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">0&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#0550ae">20&lt;/span>&lt;span style="color:#1f2328">},&lt;/span> &lt;span style="color:#0550ae">3&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#1f2328">{&lt;/span>&lt;span style="color:#0550ae">1&lt;/span>&lt;span style="color:#1f2328">:&lt;/span> &lt;span style="color:#0550ae">41&lt;/span>&lt;span style="color:#1f2328">}}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">fmt&lt;/span>&lt;span style="color:#1f2328">.&lt;/span>&lt;span style="color:#6639ba">Println&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">d&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">e&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">f&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">g&lt;/span>&lt;span style="color:#1f2328">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>数组⻓度必须是常量，且是类型的组成部分。 [2]int 和 [3]int 是不同类型。&lt;/p></description></item><item><title>包、指针、结构体和接口</title><link>https://example.org/docs/lesson03/%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AF%BE%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson03/%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AF%BE%E4%BB%B6/</guid><description>&lt;blockquote>
&lt;p>包&lt;/p>
&lt;p>指针&lt;/p>
&lt;p>结构体&lt;/p>
&lt;p>接口&lt;/p>&lt;/blockquote>
&lt;h1 id="包">包&lt;/h1>
&lt;h3 id="包介绍">包介绍&lt;/h3>
&lt;p>Go语言中支持模块化的开发理念，在Go语言中使用&lt;code>包（package）&lt;/code>来支持代码模块化和代码复用。&lt;/p>
&lt;p>包的引入使得我们可以去调用自己或者别人的模块代码，方便了我们的开发。&lt;/p>
&lt;p>例如，在之前的课件中，我们引入了 fmt 这个包。这样使得我们可以调用 fmt 包内部的函数和变量。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">package&lt;/span> &lt;span style="color:#1f2328">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">import&lt;/span> &lt;span style="color:#0a3069">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">func&lt;/span> &lt;span style="color:#6639ba">main&lt;/span>&lt;span style="color:#1f2328">(){&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#1f2328">fmt&lt;/span>&lt;span style="color:#1f2328">.&lt;/span>&lt;span style="color:#6639ba">Println&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#0a3069">&amp;#34;Hello world!&amp;#34;&lt;/span>&lt;span style="color:#1f2328">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#1f2328">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来详细介绍一下&lt;/p>
&lt;h3 id="定义包">定义包&lt;/h3>
&lt;p>我们可以根据自己的需要创建自定义包。一个包可以简单理解为一个存放&lt;code>.go&lt;/code>文件的文件夹。&lt;/p>
&lt;p>该文件夹下面的所有&lt;code>.go&lt;/code>文件都要在非注释的第一行添加如下声明，声明该文件归属的包。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">package&lt;/span> &lt;span style="color:#1f2328">packagename&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另外需要注意一个文件夹下面直接包含的文件只能归属一个包，同一个包的文件不能在多个文件夹下。&lt;/p>
&lt;p>包名为&lt;code>main&lt;/code>的包是应用程序的入口包，这种包编译后会得到一个可执行文件，而编译不包含&lt;code>main&lt;/code>包的源代码则不会得到可执行文件。&lt;/p>
&lt;h3 id="可见性">可见性&lt;/h3>
&lt;p>在同一个包内部声明的标识符都位于同一个命名空间下，在不同的包内部声明的标识符就属于不同的命名空间。想要在包的外部使用包内部的标识符就需要添加包名前缀，例如&lt;code>fmt.Println(&amp;quot;Hello world!&amp;quot;)&lt;/code>。&lt;/p>
&lt;p>如果想让一个包中的标识符（如变量、常量、类型、函数等）能被外部的包使用，那么标识符必须是对外可见的（public）。在Go语言中是通过标识符的首字母大/小写来控制标识符的对外可见（public）/不可见（private）的。在一个包内部只有首字母大写的标识符才是对外可见的。&lt;/p>
&lt;p>例如我们定义一个名为&lt;code>demo&lt;/code>的包，在其中定义了若干标识符。在另外一个包中并不是所有的标识符都能通过&lt;code>demo.&lt;/code>前缀访问到，因为只有那些首字母是大写的标识符才是对外可见的。&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span>	&lt;span style="color:#1f2328">Name&lt;/span> &lt;span style="color:#cf222e">string&lt;/span> &lt;span style="color:#57606a">// 可在包外访问的方法&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">var&lt;/span>	&lt;span style="color:#1f2328">class&lt;/span> &lt;span style="color:#cf222e">string&lt;/span> &lt;span style="color:#57606a">// 仅限包内访问的字段&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="包的引入">包的引入&lt;/h3>
&lt;p>要在当前包中使用另外一个包的内容就需要使用&lt;code>import&lt;/code>关键字引入这个包，并且import语句通常放在文件的开头，&lt;code>package&lt;/code>声明语句的下方。完整的引入声明语句格式如下:&lt;/p></description></item><item><title>后端 Go 第四次课</title><link>https://example.org/docs/lesson04/%E5%90%8E%E7%AB%AF-go-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson04/%E5%90%8E%E7%AB%AF-go-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E8%AF%BE/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>这节课主要讲 Go 语言自带的一些常用的包，学习 Go 标准库可以从标准库文档入手：&lt;/p>
&lt;ul>
&lt;li>中文（版本有些落后）： &lt;a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc&lt;/a>&lt;/li>
&lt;li>英文： &lt;a href="https://pkg.go.dev/std">https://pkg.go.dev/std&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="time">time&lt;/h2>
&lt;h3 id="时区">时区&lt;/h3>
&lt;p>在 Golang 的 &lt;code>time&lt;/code> 包中，时区用结构体 &lt;code>Location&lt;/code> 表示&lt;/p>
&lt;p>UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差。&lt;/p>
&lt;pre tabindex="0">&lt;code>UTC + 时间差 = 本地时间
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>获取时区&lt;/p>&lt;/blockquote>
&lt;p>在 Golang 的 &lt;code>time&lt;/code> 包中有两个时区变量:&lt;/p>
&lt;ul>
&lt;li>time.UTC： UTC 时间&lt;/li>
&lt;li>time.Local 本地时间&lt;/li>
&lt;/ul>
&lt;p>除此之外还可以通过 &lt;code>FixedZone&lt;/code> 、 &lt;code>LoadLocation&lt;/code> 和 &lt;code>Load&lt;/code> 方法来获取变量:&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">func&lt;/span> &lt;span style="color:#6639ba">LoadLocation&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">name&lt;/span> &lt;span style="color:#cf222e">string&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#0550ae">*&lt;/span>&lt;span style="color:#1f2328">Location&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#cf222e">error&lt;/span>&lt;span style="color:#1f2328">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>FixedZone&lt;/code> 使用给定的时区名 &lt;code>name&lt;/code> 和时间偏移量（单位秒）&lt;code>offset&lt;/code> 创建并返回一个 &lt;code>Location&lt;/code> 结构体&lt;/p>
&lt;div class="highlight">&lt;div style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
&lt;table style="border-spacing:0;padding:0;margin:0;border:0;">&lt;tr>&lt;td style="vertical-align:top;padding:0;margin:0;border:0;">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code>&lt;span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#cf222e">func&lt;/span> &lt;span style="color:#6639ba">FixedZone&lt;/span>&lt;span style="color:#1f2328">(&lt;/span>&lt;span style="color:#1f2328">name&lt;/span> &lt;span style="color:#cf222e">string&lt;/span>&lt;span style="color:#1f2328">,&lt;/span> &lt;span style="color:#1f2328">offset&lt;/span> &lt;span style="color:#cf222e">int&lt;/span>&lt;span style="color:#1f2328">)&lt;/span> &lt;span style="color:#0550ae">*&lt;/span>&lt;span style="color:#1f2328">Location&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>LoadLoaciton&lt;/code> 返回给定 &lt;code>name&lt;/code> 的 &lt;code>Location&lt;/code> 结构体，如果 &lt;code>name&lt;/code> 为 &lt;code>UTC&lt;/code> 或 &lt;code>Local&lt;/code>，则返回一个 &lt;code>time.UTC&lt;/code> 或 &lt;code>time.Local&lt;/code>，否则 &lt;code>name&lt;/code> 应该是在 IANA 时区数据库中有记录的地点名&lt;/p></description></item><item><title>并发编程</title><link>https://example.org/docs/lesson05/%E5%B9%B6%E5%8F%91/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson05/%E5%B9%B6%E5%8F%91/</guid><description>&lt;h1 id="并发">并发&lt;/h1>
&lt;blockquote>
&lt;p>本节课讲的基本都是基于单 CPU 的&lt;/p>
&lt;p>因为概念太多了，我在课件中肯定有遗漏，有问题的自己网上查一下或者在群里面问都可以&lt;/p>&lt;/blockquote>
&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>能够坚持到这里已经很厉害了，大家也能看到从第一节课到第四节课人数的变化，其实大家学到这里现在已经超越年级 80% 以上的人了，相信大家只要坚持学下去都能够成功通过考核的。&lt;/p>
&lt;p>这节课的内容是并发，并发很常见的，生活中充满了并发，而我们使用计算机就是为了解决现实生活中的问题，所以计算机中有并发就很自然了。但计算机世界中的并发可比现实世界复杂得多，这节课会带领大家了解并发的实质是什么，为什么并发控制这么难，我们要怎么解决并发过程中出现的种种问题&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>希望大家能够真正的认识、理解并解决一系列并发问题，而不是只会使用别人提供的 API。我认为蓝山工作室后端研发组如果以后出去还是从事后端行业的话，大家都是往架构师方向发展的，我们是给别人提供解决方案的，而不是只会做一个 API Programmer。所以建议大家还是多探寻一下本质而不是停留在会用的阶段。&lt;/p>
&lt;p>&lt;strong>基本要求（这节课达到基本要求就成功了）：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>学会在 Go 语言中使用并发&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>知道&lt;/strong> &lt;strong>Channel&lt;/strong> &lt;strong>select 的基本使用&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>进阶要求：课件中除了基本要求相关的全是进阶要求&lt;/p>
&lt;blockquote>
&lt;p>课件很长，基本全是我自己一个字一个字敲出来的，图也是我自己画的，有错是在所难免的，如果大家发现错别字或者讲的有问题的话麻烦大家谅解一下并及时向我反馈（可以直接在飞书文档中评论）🙏🙏🏻🙏🏼🙏🏽🙏🏾🙏🏿&lt;/p>&lt;/blockquote>
&lt;h2 id="操作系统基础知识">操作系统基础知识&lt;/h2>
&lt;p>操作系统也是一种软件，它为用户提供了一系列的接口帮助我们管理和使用硬件，我们使用的软件，编写的程序都是运行在操作系统上的，常见的操作系统有 Windows 、Linux 和 MacOS&amp;hellip;&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson05/1.png" alt="">&lt;/p>
&lt;h3 id="为什么要有操作系统">为什么要有操作系统&lt;/h3>
&lt;p>我们先来看一下计算机大概是怎么样的&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson05/2.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson05/3.png" alt="">&lt;/p>
&lt;p>程序员的任务便是使用计算机帮助人们解决一些实际问题，可这计算机这么复杂，比如想要让显示屏打印一个 “Hello World”，是不是就要让 CPU 发出指令到总线上，显示屏接受到后，再打印一个个像素点。对于我们来说是不是就需要完成如何让 CPU 发出指令，发出什么指令，怎么把指令传达给显示器等等。这要求也太高了吧，让每个程序员既要知道上层的代码如何编写，又要知道底层硬件如何交互，显然是不合理的。&lt;/p>
&lt;p>根据我们生活中的经验，比如做一个小组作业，往往都是分工完成的，每个人只需要完成自己的任务而不用关心其他任务的细节，那在计算机的世界也是这样，我们想要写代码的只需要写代码的只需要写代码，而不需要关心 CPU 是怎么运行的，显示器是怎么打印像素点的。&lt;/p>
&lt;p>所以编写一个操作系统，屏蔽掉底层硬件的细节，让我们专心写代码，就是一个很有必要的事情了。&lt;/p>
&lt;h3 id="操作系统的任务">操作系统的任务&lt;/h3>
&lt;p>一个计算机的组成大概可以分成三部分：CPU、内存和 IO 设备。&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;IO&amp;rdquo; 指的是输入/输出（Input/Output），是计算机领域中常用的术语，用于描述计算机系统中的数据传输和交换。在计算机术语中，输入/输出通常指的是计算机与外部环境（设备、存储介质或其他计算机）之间的数据交换和传输。&lt;/p>
&lt;p>显示器、鼠标、硬盘等等都是 IO 设备。&lt;/p>&lt;/blockquote>
&lt;p>操作系统要做的就是&lt;strong>管理好这三种硬件&lt;/strong>。&lt;/p>
&lt;p>CPU 就是计算机中实际执行计算任务的硬件，CPU 的工作其实就是取地址、执行，取地址，执行&amp;hellip;&lt;/p>
&lt;blockquote>
&lt;p>地址指数据或指令在内存中的位置&lt;/p>&lt;/blockquote>
&lt;p>内存就是存储数据或指令的硬件，CPU 都是和内存进行交互，磁盘中的数据要先读到内存中来才能被 CPU 知道。&lt;/p>
&lt;h3 id="其他概念">其他概念&lt;/h3>
&lt;blockquote>
&lt;p>这些内容可以先看一遍留个印象，后面再遇到的时候回来翻，看不懂也没关系&lt;/p>&lt;/blockquote>
&lt;p>&lt;strong>内核态 &amp;amp; 用户态&lt;/strong>：为了对系统资源（硬盘，显示器等等都是系统资源）进行保护和隔离，操作系统将内存空间分为了用户态和内核态，用于表示不同的运行级别和特权级别，内核态可以执行特权指令，直接操作硬件，用户态只能访问有限的资源和受限制的指令集，不能直接访问底层硬件资源。我们编写的代码都是运行在用户态之上的。&lt;/p></description></item><item><title>HTTP 服务简单案例</title><link>https://example.org/docs/lesson06/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson06/readme/</guid><description>&lt;h1 id="简单案例">简单案例&lt;/h1>
&lt;p>先尝试通过net/http包对http服务进行简单了解&lt;/p>
&lt;pre tabindex="0">&lt;code>package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;net/http&amp;#34;
)

func main() {
	http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(&amp;#34;Hello World&amp;#34;))
	})

	if err := http.ListenAndServe(&amp;#34;:8000&amp;#34;, nil); err != nil {
		fmt.Println(&amp;#34;start http server fail:&amp;#34;, err)
	}
}
&lt;/code>&lt;/pre>&lt;h2 id="http报文">http报文&lt;/h2>
&lt;p>先简单了解一下http中传送的信息是什么&lt;/p>
&lt;p>用于http协议交互的信息称为http报文&lt;/p>
&lt;h2 id="请求报文">请求报文&lt;/h2>
&lt;p>一个HTTP请求报文由请求行（request line） 、请求头部（header）、空行和请求数据4个部分组成。&lt;/p>
&lt;p>&lt;img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/143dae14a2294bf9ab8884cd819ccece~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="请求报文">&lt;/p>
&lt;p>&lt;strong>请求头部由关键字/值对组成，每行一对&lt;/strong>&lt;/p>
&lt;p>典型的请求头有：&lt;/p>
&lt;p>● User-Agent：产生请求的浏览器类型;&lt;/p>
&lt;p>● Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ &lt;em>/&lt;/em> ” 指示可接受全部类型，用“ type/* ”指示可接受 type 类型的所有子类型; 比如 Accept：text/xml（application/json）表示希望接受到的是xml（json）类型。&lt;/p>
&lt;p>● Accept-Language：客户端可接受的自然语言;&lt;/p>
&lt;p>● Accept-Encoding：客户端可接受的编码压缩格式;&lt;/p>
&lt;p>● Accept-Charset：可接受的应答的字符集;&lt;/p></description></item><item><title>MySQL 数据库</title><link>https://example.org/docs/lesson07/lesson7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson07/lesson7/</guid><description>&lt;h1 id="mysql">MySQL&lt;/h1>
&lt;p>&lt;img src="https://camo.githubusercontent.com/0d321bc853789843d8659f9d694de2f1d5149d5cba6b792a114824ec98e2ebf5/68747470733a2f2f73312e617831782e636f6d2f323032322f31312f31372f7a6d6e5556732e706e67" alt="img">&lt;/p>
&lt;h2 id="概念篇">概念篇&lt;/h2>
&lt;h3 id="什么是数据库">什么是数据库？&lt;/h3>
&lt;p>数据库（Database）是指存储数据的容器，也被称为数据存储库（Data Store）。数据库能够存储大量结构化和非结构化的数据，包括文本、数字、图像、音频等各种类型的数据。&lt;/p>
&lt;p>根据数据存储方式和结构的不同，数据库可以分为关系型数据库(如MySQL、Oracle、SQL Server、PostgreSQL)和非关系型数据库(如MongoDB、Cassandra、Redis、Elasticsearch)。&lt;/p>
&lt;h3 id="mysql介绍">MySQL介绍&lt;/h3>
&lt;blockquote>
&lt;p>MySQL是一个&lt;strong>关系型数据库&lt;/strong>，一种开源关系数据库管理系统（RDBMS），它使用最常用的数据库管理语言-结构化查询语言（SQL）进行数据库管理&lt;/p>&lt;/blockquote>
&lt;p>关系型数据库的数据都以&lt;strong>数据表&lt;/strong>的形式进行存储和管理。&lt;/p>
&lt;p>表是一种二维行列表格，关系型数据库中的数据通常以表的形式存储，如图所示&lt;/p>
&lt;p>&lt;img src="https://camo.githubusercontent.com/e04f85a224ede31a3e08285692578a8f99b5b5b80d550fbf9e0fa2b6eaadebfe/68747470733a2f2f73312e617831782e636f6d2f323032322f31312f31392f7a4b39394a672e706e67" alt="img">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>列（column）&lt;/code> - 表中的一个字段 ，如图中&lt;code>patient_id&lt;/code> 。所有表都是由一个或多个列组成的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>行（row）&lt;/code> - 表中的一个记录，比如第一行，这条记录，记录下了小红的信息(病人号、姓名、年龄、身高体重等等)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>主键（primary key）&lt;/code> - 一列（或一组列），其值能够唯一标识表中每一行。&lt;/p>
&lt;blockquote>
&lt;p>比如图2中每个patient_id，都标识了一个&lt;strong>独一无二&lt;/strong>的病人&lt;/p>
&lt;p>又比如b站的uid，也标识了一个&lt;strong>独一无二&lt;/strong>的用户&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h4 id="sql">SQL&lt;/h4>
&lt;blockquote>
&lt;p>SQL 是一种&lt;strong>操作数据库&lt;/strong>的语言，包括创建数据库、删除数据库、查询记录、修改记录、添加字段等。&lt;/p>
&lt;p>SQL 是关系型数据库的标准语言，所有的关系型数据库管理系统（RDBMS）都将 SQL 作为其标准处理语言。&lt;/p>&lt;/blockquote>
&lt;p>SQL有以下用途：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>允许用户访问关系型数据库系统中的数据；(&lt;strong>查数据&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许用户描述数据；(&lt;strong>自定义要查哪些数据&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许用户定义数据库中的数据，并处理该数据；(&lt;strong>建表&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许将 SQL 模块、库或者预处理器嵌入到其它编程语言中；(&lt;strong>在Go中使用SQL&lt;/strong>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许用户创建和删除数据库、表、数据项（记录）；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许用户在数据库中创建视图、存储过程、函数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>允许用户设置对表、存储过程和视图的权限；&lt;/p>
&lt;p>&lt;strong>SQL命令分为三类&lt;/strong>&lt;/p>
&lt;p>1.DDL - Data Definition Language，数据定义语言&lt;/p>
&lt;blockquote>
&lt;p>对数据的结构和形式进行定义，一般用于数据库和表的创建、删除、修改等。&lt;/p>&lt;/blockquote>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>命令&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>CREATE&lt;/td>
 &lt;td>用于在数据库中创建一个新表、一个视图或者其它对象。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ALTER&lt;/td>
 &lt;td>用于修改现有的数据库，比如表、记录。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DROP&lt;/td>
 &lt;td>用于删除整个表、视图或者数据库中的其它对象&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>2.DML - Data Manipulation Language，数据处理语言&lt;/p>
&lt;blockquote>
&lt;p>对数据库中的数据进行处理，一般用于数据项（记录）的插入、删除、修改和查询。&lt;/p>&lt;/blockquote>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>命令&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>SELECT&lt;/td>
 &lt;td>用于从一个或者多个表中检索某些记录。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>INSERT&lt;/td>
 &lt;td>插入一条记录。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>UPDATE&lt;/td>
 &lt;td>修改记录。&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>DELETE&lt;/td>
 &lt;td>删除记录。&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>3.DCL - Data Control Language，数据控制语言&lt;/p></description></item><item><title>Redis 和 MongoDB</title><link>https://example.org/docs/lesson08/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson08/readme/</guid><description>&lt;h1 id="lesson8redis-mangodb">lesson8：redis, mangodb&lt;/h1>
&lt;p>上节课讲了关系型数据库&lt;strong>mysql&lt;/strong>，这节课我们来了解一下非关系型数据库&lt;strong>redis&lt;/strong> 和 &lt;strong>mangodb&lt;/strong>&lt;/p>
&lt;h2 id="非关系型数据库">非关系型数据库&lt;/h2>
&lt;p>NoSQL：非关系型数据库，主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统，常见的有&lt;strong>Redis / HBase /MongoDB /CouchDB /Neo4J&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>优点：&lt;/strong>
1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式。2、速度快：NoSQL可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；3、高扩展性；4、成本低。&lt;/p>
&lt;p>&lt;strong>缺点：&lt;/strong>
1、一般而言没有太强的事务处理能力；2、数据结构相对复杂，复杂查询方面稍欠。&lt;/p>&lt;/blockquote>
&lt;h2 id="redis">Redis&lt;/h2>
&lt;p>Redis全称为：Remote Dictionary Server（远程数据服务），该软件使用C语言编写，Redis是一个key-value存储系统，其有以下特点。&lt;/p>
&lt;ul>
&lt;li>1:性能高,单线程非常适合&lt;strong>读多写少&lt;/strong>的场景,可以减轻数据库压力,&lt;/li>
&lt;li>2.集群分布式存储,可以横向拓展,可以做到高可用.&lt;/li>
&lt;li>3.数据结构类型丰富数据类型&lt;/li>
&lt;li>4.支持数据持久化&lt;/li>
&lt;li>5.支持事务（一般不用）一般通过lua脚本去实现&lt;/li>
&lt;/ul>
&lt;h2 id="redis数据类型和命令">Redis数据类型和命令&lt;/h2>
&lt;p>Redis 目前有9种数据类型和&lt;/p>
&lt;p>**5种常见类型：**String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）&lt;/p>
&lt;p>**4种新增类型：**BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）&lt;/p>
&lt;h3 id="基本命令">&lt;strong>基本命令&lt;/strong>&lt;/h3>
&lt;p>&lt;code>redis-cli&lt;/code> 进入Redis命令行界面&lt;/p>
&lt;pre tabindex="0">&lt;code>root@bc2c25de5155:/data# redis-cli
127.0.0.1:6379&amp;gt;
&lt;/code>&lt;/pre>&lt;p>如果设置了密码需要auth认证
&lt;code>auth [username] password &lt;/code> 默认用户是&lt;code>default&lt;/code>&lt;/p>
&lt;pre tabindex="0">&lt;code>127.0.0.1:6379&amp;gt; auth default 123456
OK
127.0.0.1:6379&amp;gt; auth 123456
OK
&lt;/code>&lt;/pre>&lt;p>&lt;code>dbsize&lt;/code> 查看数据库的key数量&lt;/p>
&lt;pre tabindex="0">&lt;code>127.0.0.1:6379&amp;gt; dbsize
(integer) 1
&lt;/code>&lt;/pre>&lt;p>&lt;code>select index&lt;/code>选择数据库 默认是0&lt;/p>
&lt;pre tabindex="0">&lt;code>127.0.0.1:6379&amp;gt; select 0
OK
&lt;/code>&lt;/pre>&lt;p>&lt;code>help @基本数据类型&lt;/code> 查看命令&lt;/p>
&lt;pre tabindex="0">&lt;code>127.0.0.1:6379&amp;gt; help @string
&lt;/code>&lt;/pre>&lt;p>&lt;code>flushall&lt;/code> 删除所有key&lt;/p></description></item><item><title>第九课</title><link>https://example.org/docs/lesson09/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson09/readme/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>俗话说，不会 linux 的后端不是好运维，后端开发人员也需要懂一点运维。&lt;/p>
&lt;p>展望目前行业的发展，自动化运维和 DevOps 等理念的诞生和推广，其实也让运维和开发的边界变得更加的模糊，运维人员可能需要掌握一些开发语言来实现编写自动化运维的脚本，或者需要掌握一些开发的语言和工作流程以便更好地协作。开发人员可能也需要了解运维的内容以便更好地开发实际有用的软件以及更好地协作。&lt;/p>
&lt;h2 id="linux-基础">Linux 基础&lt;/h2>
&lt;h3 id="啥是linux">啥是linux?&lt;/h3>
&lt;blockquote>
&lt;p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。 严格来讲，Linux这个词本身只表示&lt;strong>Linux内核&lt;/strong>，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。&lt;/p>&lt;/blockquote>
&lt;p>全世界 99% 服务器的操作系统都是 Linux&lt;/p>
&lt;h3 id="linux-的各个发行版">linux 的各个发行版&lt;/h3>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-c79ecff3534b9e135aac51673172a7cf_720w.webp" alt="img">&lt;/p>
&lt;p>Linux发行版主要有三个分支：Debian、Slackware、Redhat。
(1)Debian:（以社区的方式运作）&lt;/p>
&lt;ol>
&lt;li>Ubuntu:基于Debian开发的开源Linux操作系统，主要针对桌面和服务器；&lt;/li>
&lt;li>Linux Mint:基于Debian和Ubuntu的Linux发行版，致力于桌面系统对个人用户每天的工作更易用，更高效，且目标是提供一种更完整的即刻可用体验。&lt;/li>
&lt;/ol>
&lt;p>(2)slackware&lt;/p>
&lt;ol>
&lt;li>suse：基于Slackware二次开发的一款Linux,主要用于商业桌面、服务器。&lt;/li>
&lt;li>SLES(SUSE Linux Enterprise Server(SLES):企业服务器操作系统，是唯一与微软系统兼容的Linux操作系统。&lt;/li>
&lt;li>OpenSUSE:由suse发展而来，旨在推进linux的广泛使用，主要用于桌面环境，用户界面非常华丽，而且性能良好。&lt;/li>
&lt;/ol>
&lt;p>(3)Redhat&lt;/p>
&lt;ol>
&lt;li>rhel(red hat enterprise Linux):Red Hat公司发布的面向企业用户的Linux操作系统。早起版本主要用于桌面环境，免费：&lt;/li>
&lt;li>Fedora:基于Red Hat Linux终止发行后，红帽公司计划以Fedora来取代Red Hat Linux在个人领域的应用，而另外发行的Red Hat Enterprise Linux取代Red Hat Linux在商业应用的领域。Fedora的功能对于用户而言，它是一套功能完备、更新快速的免费操作系统，而对赞助者Red Hat公司而言，它是许多新技术的测试平台，被认为可用的技术最终会加入到Red Hat Enterprise Linux中。Fedora大约每六个月发布新版本。&lt;/li>
&lt;li>Centos:基于Red hat Linux提供的可自由使用源代码的企业级Linux发行版本。每个版本的Centos都会获得十年的支持（通过安全更新的方式）。新版本的Centos大约每两年发行一次，而每个版本的Centos会定期（大概6个月）更新一次，以支持新的硬件。这样，建立一个安全、低维护、稳定、高预测性、高重复性的Linux环境。&lt;/li>
&lt;/ol>
&lt;p>(4)其他发行版本：&lt;/p>
&lt;ol>
&lt;li>Gentoo:基于linux的自由操作系统，基于Linux的自由操作系统，它能为几乎任何应用程序或需求自动地作出优化和定制。追求极限的配置、性能，以及顶尖的用户和开发者社区，都是Gentoo体验的标志特点， Gentoo的哲学是自由和选择。得益于一种称为Portage的技术，Gentoo能成为理想的安全服务器、开发工作站、专业桌面、游戏系统、嵌入式解决方案或者别的东西&amp;ndash;你想让它成为什么，它就可以成为什么。由于它近乎无限的适应性，可把Gentoo称作元发行版。&lt;/li>
&lt;li>Aech Linux(或称Arch):以轻量简洁为设计理念的Linux发行版。其开发团队秉承简洁、优雅和代码最小化的设计宗旨。&lt;/li>
&lt;/ol>
&lt;h3 id="linux-目录">linux 目录&lt;/h3>
&lt;p>根目录 &lt;code>/&lt;/code> 是整个文件系统的起始点，但实际上，Linux 文件系统采用了一种层次结构来组织文件和目录。&lt;/p></description></item><item><title>Docker 容器化</title><link>https://example.org/docs/lesson10/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson10/docker/</guid><description>&lt;h2 id="基础入门">基础入门&lt;/h2>
&lt;h3 id="虚拟化介绍">虚拟化介绍&lt;/h3>
&lt;p>虚拟化的核心是对资源的抽象
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702438754171-97bdd4a8-db32-4328-bb3f-9095d25b2360.png#averageHue=%23e7e4df&amp;amp;clientId=u9709a842-eab8-4&amp;amp;from=paste&amp;amp;height=367&amp;amp;id=u5057db18&amp;amp;originHeight=808&amp;amp;originWidth=2160&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=504397&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u856ae5dd-554f-4a08-8d27-ffea9210383&amp;amp;title=&amp;amp;width=981.8181605378463" alt="image.png">&lt;/p>
&lt;h3 id="docker-为什么比虚拟化更加轻量">Docker 为什么比虚拟化更加轻量？&lt;/h3>
&lt;p>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统
层。 Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。&lt;/p>
&lt;h2 id="核心概念">核心概念&lt;/h2>
&lt;h3 id="docker-镜像">Docker 镜像&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702438912604-824274f5-6a0b-42dd-a4f7-f79ddb293494.png#averageHue=%23e8e3d4&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=265&amp;amp;id=u8ae170cd&amp;amp;originHeight=584&amp;amp;originWidth=1834&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=302120&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u55186291-3f16-419f-89ef-cced3e7d6dd&amp;amp;title=&amp;amp;width=833.6363455677824" alt="image.png">&lt;/p>
&lt;h3 id="容器">容器&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702438946065-9831bbd6-3ff0-4b81-809e-0a6fd7305cd5.png#averageHue=%23e1ded7&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=263&amp;amp;id=ud8f51fdb&amp;amp;originHeight=578&amp;amp;originWidth=1788&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=532777&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=ue5e93712-9b28-4bce-b905-de2659bfe55&amp;amp;title=&amp;amp;width=812.7272551118839" alt="image.png">&lt;/p>
&lt;h3 id="仓库">仓库&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702439057339-c22ed91f-8fe2-4890-be11-7fc0307eeab0.png#averageHue=%23e1e1e1&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=585&amp;amp;id=ud45343f7&amp;amp;originHeight=1288&amp;amp;originWidth=1778&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=1013233&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u715e3888-6c35-472b-ba57-849b8048aab&amp;amp;title=&amp;amp;width=808.1818006649494" alt="image.png">&lt;/p>
&lt;h2 id="使用-docker-镜像">使用 Docker 镜像&lt;/h2>
&lt;h3 id="pull">pull&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702439219096-0bbaa35c-1a7f-4678-a92c-184569b7ed23.png#averageHue=%23e7e7e7&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=64&amp;amp;id=u824e9db4&amp;amp;originHeight=140&amp;amp;originWidth=1824&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=66219&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u9bd6bf6d-17dc-4a96-be67-f4ccd61fcc1&amp;amp;title=&amp;amp;width=829.090891120848" alt="image.png">
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702439239294-ee16b5ef-c6a1-4468-b4a9-50c0061e88a8.png#averageHue=%23e9e9e9&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=64&amp;amp;id=u903445dd&amp;amp;originHeight=140&amp;amp;originWidth=1786&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=62599&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u88652cbe-c92c-4993-bae4-52c39908ae5&amp;amp;title=&amp;amp;width=811.818164222497" alt="image.png">
加上仓库地址
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702439313494-c9a4c1a8-8c8a-4234-bd34-b6d5c1631bbb.png#averageHue=%23e6e6e6&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=282&amp;amp;id=uc8eb4785&amp;amp;originHeight=620&amp;amp;originWidth=1862&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=320991&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u45f6c3d1-6f6a-4d22-9e4d-0ea17bc9301&amp;amp;title=&amp;amp;width=846.363618019199" alt="image.png">&lt;/p>
&lt;h3 id="ls-tag-inspect">ls 、tag、 inspect&lt;/h3>
&lt;h4 id="使用-images-命令列出镜像">使用 images 命令列出镜像&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702439494076-cacb03e7-9a22-4326-84e5-feb4357a7b0b.png#averageHue=%23ececec&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=434&amp;amp;id=uc877359b&amp;amp;originHeight=954&amp;amp;originWidth=1852&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=360135&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u6c21b067-9173-4759-8c66-73a6d242f27&amp;amp;title=&amp;amp;width=841.8181635722646" alt="image.png">&lt;/p>
&lt;h4 id="使用-tag-命令添加镜像标签">使用 tag 命令添加镜像标签&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702448467481-812a873f-8b58-4c5d-b866-64e1588c89a8.png#averageHue=%23ececec&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=449&amp;amp;id=ua2bb7b0f&amp;amp;originHeight=988&amp;amp;originWidth=1922&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=402577&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u05729b1c-193a-47eb-affe-bd17b0a8c12&amp;amp;title=&amp;amp;width=873.6363447008058" alt="image.png">&lt;/p>
&lt;h4 id="使用-inspect-命令查看详细信息">使用 inspect 命令查看详细信息&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702448717309-9a4fdfaa-546d-4659-bca6-f29662eb6764.png#averageHue=%23f3f3f3&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=421&amp;amp;id=u2283e557&amp;amp;originHeight=926&amp;amp;originWidth=1792&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=225155&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u58a82cdd-f482-4578-bbad-0c38bb43127&amp;amp;title=&amp;amp;width=814.5454368906577" alt="image.png">&lt;/p>
&lt;h3 id="docker-search-搜索镜像">docker search 搜索镜像&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702448858978-d851072c-49b0-48bb-9573-e5484da320c1.png#averageHue=%23eeeeee&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=503&amp;amp;id=u37fe0bb5&amp;amp;originHeight=1106&amp;amp;originWidth=1816&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=391684&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u5a3505b5-137e-46cb-a3b5-b644d3a00d7&amp;amp;title=&amp;amp;width=825.4545275633004" alt="image.png">&lt;/p>
&lt;h3 id="删除和清理镜像-rm-prune">删除和清理镜像 rm 、prune&lt;/h3>
&lt;h4 id="image-rm-rmi">image rm 、rmi&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702448985445-9d37c5b4-0fb9-4c1d-af12-09126562c2dd.png#averageHue=%23ededed&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=446&amp;amp;id=ue1d28f50&amp;amp;originHeight=982&amp;amp;originWidth=1940&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=411714&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u4b8ba3fe-cb3d-4dea-97a8-c8e39933995&amp;amp;title=&amp;amp;width=881.8181627052878" alt="image.png">&lt;/p>
&lt;h4 id="prune">prune&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449164655-04ae768a-cf2b-4fc0-b752-a5499fa9f9d7.png#averageHue=%23ececec&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=238&amp;amp;id=u65165132&amp;amp;originHeight=524&amp;amp;originWidth=1790&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=184668&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u2c321983-7ab9-40b8-bacc-bdefe711ae7&amp;amp;title=&amp;amp;width=813.6363460012708" alt="image.png">&lt;/p>
&lt;h3 id="创建镜像">创建镜像&lt;/h3>
&lt;h4 id="基于现有的容器创建commit">基于现有的容器创建｜commit&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449363468-5a57c46c-c584-4cf6-aebf-901ac73fc6e5.png#averageHue=%23ececec&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=276&amp;amp;id=u47a661e0&amp;amp;originHeight=608&amp;amp;originWidth=1806&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=212098&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=ua2a2dbf5-284a-4b2e-821d-aaaf55bedf1&amp;amp;title=&amp;amp;width=820.9090731163659" alt="image.png">
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449383541-3cd98212-42cf-449c-9f44-69592cb54ead.png#averageHue=%23ececec&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=436&amp;amp;id=u63688a6c&amp;amp;originHeight=960&amp;amp;originWidth=1830&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=360650&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=uf61c65e9-4fed-4b4a-8246-a93823b8c2e&amp;amp;title=&amp;amp;width=831.8181637890086" alt="image.png">&lt;/p>
&lt;h4 id="基于本地模板导入--import">基于本地模板导入 | import&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449443582-e8790071-1a3d-4f27-91b5-316fc802d637.png#averageHue=%23e9e9e9&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=364&amp;amp;id=uafb09a65&amp;amp;originHeight=800&amp;amp;originWidth=1806&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=392487&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u427e1f7d-f1e2-46c1-8267-f718209c82a&amp;amp;title=&amp;amp;width=820.9090731163659" alt="image.png">&lt;/p>
&lt;h4 id="基于dockerfile-创建build">基于Dockerfile 创建｜build&lt;/h4>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449518712-56e61865-07a9-4b25-8f97-f4e497c61e0a.png#averageHue=%23efefef&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=401&amp;amp;id=u6df1f67f&amp;amp;originHeight=882&amp;amp;originWidth=1844&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=364318&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=uc44fff40-fc35-4bf3-bfc9-24143be88c7&amp;amp;title=&amp;amp;width=838.1818000147169" alt="image.png">&lt;/p>
&lt;h3 id="存出和载入镜像-saveload">存出和载入镜像 ｜save、load&lt;/h3>
&lt;p>&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702449579089-1703bc65-4e8d-4ecd-8602-b26cb3f26897.png#averageHue=%23efefef&amp;amp;clientId=uadceb3de-c3ff-4&amp;amp;from=paste&amp;amp;height=599&amp;amp;id=u11544248&amp;amp;originHeight=1318&amp;amp;originWidth=1850&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=479566&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u5fba7430-19cf-4349-8932-257154e7a69&amp;amp;title=&amp;amp;width=840.9090726828776" alt="image.png">&lt;/p>
&lt;h3 id="上传镜像--push">上传镜像 | push&lt;/h3>
&lt;p>注意要改tag为user/xxx
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702450020380-23ffacef-8e12-4cfc-a5b2-dbb6eec2c01b.png#averageHue=%23ededed&amp;amp;clientId=u5254a251-eff3-4&amp;amp;from=paste&amp;amp;height=489&amp;amp;id=u544de7ca&amp;amp;originHeight=1076&amp;amp;originWidth=1784&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=377203&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=u3b4dfc28-9c80-48ce-9e6a-aef934eb6b9&amp;amp;title=&amp;amp;width=810.9090733331101" alt="image.png">&lt;/p>
&lt;h2 id="操作-docker-容器">操作 Docker 容器&lt;/h2>
&lt;p>概要
&lt;img src="https://cdn.nlark.com/yuque/0/2023/png/33645769/1702450553257-3c16f15d-d2f3-4d5f-a286-d2dab5a47e15.png#averageHue=%23e1e1e1&amp;amp;clientId=u48fb3c54-5bb2-4&amp;amp;from=paste&amp;amp;height=185&amp;amp;id=u1af22ad2&amp;amp;originHeight=406&amp;amp;originWidth=1814&amp;amp;originalType=binary&amp;amp;ratio=2.200000047683716&amp;amp;rotation=0&amp;amp;showTitle=false&amp;amp;size=246363&amp;amp;status=done&amp;amp;style=none&amp;amp;taskId=udc46e4d7-4b69-492f-a9ae-4a069a440d5&amp;amp;title=&amp;amp;width=824.5454366739135" alt="image.png">&lt;/p></description></item><item><title>单体架构实战</title><link>https://example.org/docs/lesson11/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson11/readme/</guid><description>&lt;h1 id="单体架构实战">单体架构实战&lt;/h1>
&lt;p>上了之前的课但是还没听懂？感觉会用但是写起来感到寸步难行？本节课会教大家从0开始写一个完整的好项目&lt;/p>
&lt;h2 id="前置知识">前置知识&lt;/h2>
&lt;p>在上本节课之前，你需要了解到的一些前置知识。&lt;/p>
&lt;h3 id="viper-配置管理">viper (配置管理)&lt;/h3>
&lt;p>&lt;img src="https://example.org/images/lesson11/viper.PNG" alt="viper">&lt;/p>
&lt;p>通常，在一个或多个项目中我们需要使用定义一些配置（数据库的配置，项目功能的参数配置），从而我们可以在项目的开发或上线过程中可以快速的自定义项目的一些功能，以便满足我们的一些特定需求，那么项目中的配置如何管理呢，在 Go 中我们需要用到叫做 Viper 配置管理器。
尽管 Go 有官方库可以读取配置，但是通常情况下，推荐使用viper库来读取配置文件， viper 支持以下功能：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>支持 yaml、json、toml、hcl 等格式的配置文件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以从文件、io.Reader 、环境变量、cli命令行 中读取配置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持自动转换的类型解析&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以远程从Key/Value中读取配置，需要导入 viper/remote 包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>监听配置文件。以往我们修改配置文件后需要重启服务生效，而Viper使用watch函数可以让配置自动生效&lt;/p>
&lt;p>&lt;a href="https://www.liwenzhou.com/posts/Go/viper_tutorial/">Go语言配置管理神器——Viper中文教程&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="logger日志管理">logger(日志管理）&lt;/h3>
&lt;p>&lt;img src="https://example.org/images/lesson11/zap.PNG" alt="zap">&lt;/p>
&lt;blockquote>
&lt;p>程序员的日常离不开日志，日志就好比私人秘书，负责运行周期一切 trace 工作。优秀的日志实践能极大帮助地程序员快速定位问题，减少在线错误报警。
在 Go 中我们用到 zap 作为日志记录器&lt;/p>&lt;/blockquote>
&lt;p>Go 在 1.21.3 中新推出了 slog ，但是无论从自由度还是性能上都比不过已有的一些第三方库，其中 zap 就是非常好用的一款日志管理组件&lt;/p>
&lt;p>&lt;a href="http://www.yunweipai.com/23766.html">日志实践准则&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.liwenzhou.com/posts/Go/zap/">在Go语言项目中使用Zap日志库&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/7032091256457003044">Zap 日志库实践&lt;/a>&lt;/p>
&lt;h2 id="后端到底是怎么工作的">后端到底是怎么工作的？&lt;/h2>
&lt;p>上了前面的课，大家应该能够明白后端其实就是负责业务逻辑与数据处理的，但是在实际生产环境中，后端是如何在互联网中发挥作用的呢？&lt;/p>
&lt;p>我们都知道，gin 是一个 http 框架，http 是传输协议，那么 gin 框架也就是和 web（World Wide Web) 息息相关，也是 Go 作为一款擅长于后端编程的核心框架之一（当然 http 框架还有很多），为什么我们用 gin 框架写一个接口（API）就能处理请求呢，最后又把消息返回给谁了呢，这些问题都会在这节课得到解答。&lt;/p></description></item><item><title>第十二课</title><link>https://example.org/docs/lesson12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>&lt;h3 id="一消息队列mq概述">一、消息队列(MQ)概述&lt;/h3>
&lt;p>消息队列（Message Queue），是分布式系统中重要的组件，其通用的使用场景可以简单地描述为：&lt;/p>
&lt;blockquote>
&lt;p>当不需要立即获得结果，但是并发量又需要进行控制的时候，大概就是需要使用消息队列的时候。&lt;/p>&lt;/blockquote>
&lt;p>消息队列主要解决了应用耦合、异步处理、流量削锋等问题。&lt;/p>
&lt;h3 id="二消息队列使用场景">二、消息队列使用场景&lt;/h3>
&lt;h4 id="21-异步处理">2.1 异步处理&lt;/h4>
&lt;p>多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；&lt;/p>
&lt;p>具体场景：用户为了使用某个应用，进行注册，系统需要发送注册邮件并验证短信。对这两个操作的处理方式有两种：串行及并行。&lt;/p>
&lt;p>（1）串行方式：新注册信息生成后，先发送注册邮件，再发送验证短信；&lt;/p>
 &lt;img src="https://example.org/images/lesson12/1.png">
&lt;p>在这种方式下，需要最终发送验证短信后再返回给客户端。&lt;/p>
&lt;p>（2）并行处理：新注册信息写入后，由发短信和发邮件并行处理；&lt;/p>
 &lt;img src="https://example.org/images/lesson12/2.png">
&lt;p>在这种方式下，发短信和发邮件 需处理完成后再返回给客户端。&lt;/p>
&lt;p>假设以上三个子系统处理的时间均为50ms，且不考虑网络延迟，则总的处理时间：&lt;/p>
&lt;blockquote>
&lt;p>串行：50+50+50=150ms 并行：50+50 = 100ms&lt;/p>&lt;/blockquote>
&lt;p>若使用消息队列：&lt;/p>
 &lt;img src="https://example.org/images/lesson12/3.png">
&lt;p>并在写入消息队列后立即返回成功给客户端，则总的响应时间依赖于写入消息队列的时间，而写入消息队列的时间本身是可以很快的，基本可以忽略不计，因此总的处理时间相比串行提高了2倍，相比并行提高了一倍；&lt;/p>
&lt;h4 id="22-应用耦合">2.2 应用耦合&lt;/h4>
&lt;p>多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；&lt;/p>
&lt;p>具体场景：用户使用QQ相册上传一张图片，人脸识别系统会对该图片进行人脸识别，一般的做法是，服务器接收到图片后，图片上传系统立即调用人脸识别系统，调用完成后再返回成功，如下图所示：&lt;/p>
 &lt;img src="https://example.org/images/lesson12/4.png">
&lt;p>该方法有如下缺点：&lt;/p>
&lt;ul>
&lt;li>人脸识别系统被调失败，导致图片上传失败；&lt;/li>
&lt;li>延迟高，需要人脸识别系统处理完成后，再返回给客户端，即使用户并不需要立即知道结果；&lt;/li>
&lt;li>图片上传系统与人脸识别系统之间互相调用，需要做耦合；&lt;/li>
&lt;/ul>
&lt;p>若使用消息队列：&lt;/p>
 &lt;img src="https://example.org/images/lesson12/6.png">
&lt;p>客户端上传图片后，图片上传系统将图片信息如uin、批次写入消息队列，直接返回成功；而人脸识别系统则定时从消息队列中取数据，完成对新增图片的识别。&lt;/p>
&lt;p>此时图片上传系统并不需要关心人脸识别系统是否对这些图片信息的处理、以及何时对这些图片信息进行处理。事实上，由于用户并不需要立即知道人脸识别结果，人脸识别系统可以选择不同的调度策略，按照闲时、忙时、正常时间，对队列中的图片信息进行处理。&lt;/p>
&lt;h4 id="23-限流削峰">2.3 限流削峰&lt;/h4>
&lt;p>广泛应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；&lt;/p>
&lt;p>具体场景：购物网站开展秒杀活动，一般由于瞬时访问量过大，服务器接收过大，会导致流量暴增，相关系统无法处理请求甚至崩溃。而加入消息队列后，系统可以从消息队列中取数据，相当于消息队列做了一次缓冲。&lt;/p>
 &lt;img src="https://example.org/images/lesson12/5.png">
&lt;p>该方法有如下优点：&lt;/p>
&lt;ol>
&lt;li>请求先入消息队列，而不是由业务处理系统直接处理，做了一次缓冲,极大地减少了业务处理系统的压力；&lt;/li>
&lt;li>队列长度可以做限制，事实上，秒杀时，后入队列的用户无法秒杀到商品，这些请求可以直接被抛弃，返回活动已结束或商品已售完信息；&lt;/li>
&lt;/ol>
&lt;h4 id="24-消息驱动的系统">2.4 消息驱动的系统&lt;/h4>
&lt;p>系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；&lt;/p>
&lt;p>具体场景：用户新上传了一批照片， 人脸识别系统需要对这个用户的所有照片进行聚类，聚类完成后由对账系统重新生成用户的人脸索引(加快查询)。这三个子系统间由消息队列连接起来，前一个阶段的处理结果放入队列中，后一个阶段从队列中获取消息继续处理。&lt;/p>
 &lt;img src="https://example.org/images/lesson12/7.png">
&lt;p>该方法有如下优点：&lt;/p>
&lt;ul>
&lt;li>避免了直接调用下一个系统导致当前系统失败；&lt;/li>
&lt;li>每个子系统对于消息的处理方式可以更为灵活，可以选择收到消息时就处理，可以选择定时处理，也可以划分时间段按不同处理速度处理；&lt;/li>
&lt;/ul>
&lt;h3 id="三消息系统分类">&lt;strong>三、消息系统分类&lt;/strong>&lt;/h3>
&lt;p>我们知道常见的消息系统有RabbtMQ、RocketMQ、Kafka、ZeroMQ等，但是这些消息系统中所使用的消息模式如下两种：&lt;/p>
&lt;h4 id="31-peer-to-peer-queue">3.1 &lt;strong>Peer-to-Peer (Queue)&lt;/strong>&lt;/h4>
&lt;p>简称PTP队列模式，也可以理解为点到点。例如单发邮件，我发送一封邮件给小徐，我发送过之后邮件会保存在服务器的云端，当小徐打开邮件客户端并且成功连接云端服务器后，可以自动接收邮件或者手动接收邮件到本地，当服务器云端的邮件被小徐消费过之后，云端就不再存储(这根据邮件服务器的配置方式而定)。&lt;/p>
 &lt;img src="https://example.org/images/lesson12/8.webp">
&lt;p>&lt;strong>Peer-to-Peer模式工作原理：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>消息生产者&lt;code>Producer1&lt;/code>生产消息到&lt;code>Queue&lt;/code>，然后&lt;code>Consumer1&lt;/code>从Queue中取出并且消费消息。&lt;/li>
&lt;li>消息被消费后，&lt;code>Queue&lt;/code>将不再存储消息，其它所有&lt;code>Consumer&lt;/code>不可能消费到已经被其它Consumer消费过的消息。&lt;/li>
&lt;li>&lt;code>Queue&lt;/code>支持存在多个&lt;code>Producer&lt;/code>，但是对一条消息而言，只会有一个&lt;code>Consumer&lt;/code>可以消费，其它Consumer则不能再次消费。&lt;/li>
&lt;li>但&lt;code>Consumer&lt;/code>不存在时，消息则由&lt;code>Queue&lt;/code>一直保存，直到有&lt;code>Consumer&lt;/code>把它消费。&lt;/li>
&lt;/ol>
&lt;h4 id="32-publishsubscribetopic">3.2 &lt;strong>Publish/Subscribe（Topic）&lt;/strong>&lt;/h4>
&lt;p>简称发布/订阅模式。例如我微博有30万粉丝，我今天更新了一条微博，那么这30万粉丝都可以接收到我的微博更新，大家都可以消费我的消息。&lt;/p>
&lt;blockquote>
&lt;p>注：以下图示中的&lt;code>Pushlisher&lt;/code>是错误的名词，正确的为&lt;code>Publisher&lt;/code>&lt;/p>&lt;/blockquote>
 &lt;img src="https://example.org/images/lesson12/9.webp">
&lt;p>&lt;strong>Publish/Subscribe模式工作原理：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>消息发布者&lt;code>Publisher&lt;/code>将消息发布到主题&lt;code>Topic&lt;/code>中，同时有多个消息消费者 &lt;code>Subscriber&lt;/code>消费该消息。&lt;/li>
&lt;li>和PTP方式不同，发布到&lt;code>Topic&lt;/code>的消息会被所有订阅者消费。&lt;/li>
&lt;li>当发布者发布消息，不管是否有订阅者，都不会报错信息。&lt;/li>
&lt;li>一定要先有消息发布者，后有消息订阅者。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意：Kafka所采用的就是发布/订阅模式，被称为一种高吞吐量、持久性、分布式的发布订阅的消息队列系统。&lt;/strong>&lt;/p></description></item><item><title>微服务入门</title><link>https://example.org/docs/lesson13/lesson13/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson13/lesson13/</guid><description>&lt;h1 id="微服务入门">微服务入门&lt;/h1>
&lt;h2 id="单体应用">单体应用&lt;/h2>
&lt;p>与微服务相对的另一个概念是传统的「单体式应用程序」( Monolithic application )，单体式应用内部包含了所有需要的服务。而且各个服务功能模块有很强的耦合性，也就是相互依赖彼此，很难拆分和扩容。&lt;/p>
&lt;h3 id="单体应用的优点">单体应用的优点&lt;/h3>
&lt;ul>
&lt;li>开发简洁，功能都在单个程序内部，便于软件设计和开发规划。&lt;/li>
&lt;li>容易部署，程序单一不存在分布式集群的复杂部署环境，降低了部署难度。&lt;/li>
&lt;li>容易测试，没有各种复杂的服务调用关系，都是内部调用方便测试。&lt;/li>
&lt;/ul>
&lt;h3 id="单体应用的缺点">单体应用的缺点&lt;/h3>
&lt;p>单体架构随着功能增多，不可避免的是研发效能的降低：研发周期变长、研发资源占用增多。从而引发的情况是：新员工培训时间增多、员工加班时间变长、员工要求涨薪或者跳槽。到了这种情况就说明，单体架构已经不能够满足企业发展需要，这个时候，需要升级架构来提升研发效能，比如微服务架构。&lt;/p>
&lt;h2 id="微服务">微服务&lt;/h2>
&lt;blockquote>
&lt;p>2014年，&lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FMartin_Fowler">Martin Fowler&lt;/a> 与 &lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fw%2Findex.php%3Ftitle%3DJames_Lewis%26action%3Dedit%26redlink%3D1">James Lewis&lt;/a> 共同提出了微服务的概念，定义了微服务是由以单一应用程序构成的小服务，自己拥有自己的行程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 &lt;a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FDocker">Docker&lt;/a>) 能力，服务可以用不同的编程语言与数据库等组件实现 。「维基百科」&lt;/p>&lt;/blockquote>
&lt;p>微服务是一种架构风格：&lt;/p>
&lt;ol>
&lt;li>一组小服务&lt;/li>
&lt;li>每个服务运行在独立进程中&lt;/li>
&lt;li>服务之间使用轻量级通信&lt;/li>
&lt;li>服务可独立部署&lt;/li>
&lt;li>是基于业务能力实现&lt;/li>
&lt;li>无集中式管理&lt;/li>
&lt;/ol>
&lt;p>业界对于微服务还有一句更加剪短的描述：&lt;strong>微服务是一组小而自治的服务&lt;/strong>。&lt;/p>
&lt;h3 id="微服务优点">微服务优点&lt;/h3>
&lt;p>优点很多，我们介绍几个比较重要的。&lt;/p>
&lt;h4 id="隔离性">隔离性&lt;/h4>
&lt;p>一个服务不可用不会导致另一个服务也瘫痪，因为各个服务是相互独立和自治的系统。这在单体应用程序中是做不到的，单体应用程序中某个模块瘫痪，必将导致整个系统不可用，当然，单体程序也可以在不同机器上部署同样的程序来实现备份，不过，同样存在上面说的资源浪费问题。&lt;/p>
&lt;h4 id="可扩展性">可扩展性&lt;/h4>
&lt;p>庞大的单体服务如果出现性能瓶颈只能对软件整体进行扩展，可能真正影响性能的只是其中一个很小的模块，我们也不得不付出升级整个应用的代价。这在微服务架构中得到了改善，你可以只对那些影响性能的服务做扩展升级，这样对症下药的效果是很好的。&lt;/p>
&lt;h4 id="简化部署">简化部署&lt;/h4>
&lt;p>如果你的服务是一个超大的单体服务，有几百万行代码，即使修改了几行代码也要重新编译整个应用，这显然是非常繁琐的，而且软件变更带来的不确定性非常高，软件部署的影响也非常大。在微服务架构中，各个服务的部署是独立的，如果真出了问题也只是影响单个服务，可以快速回滚版本解决。&lt;/p>
&lt;h4 id="易优化">易优化&lt;/h4>
&lt;p>微服务架构中单个服务的代码量不会很大，这样当你需要重构或者优化这部分服务的时候，就会容易很多，毕竟，代码量越少意味着代码改动带来的影响越可控。&lt;/p>
&lt;h3 id="微服务缺点">微服务缺点&lt;/h3>
&lt;p>任何技术都存在它的弊端，没有弊端就没有新型技术的演进。&lt;/p>
&lt;p>服务的拆分和定义是一种挑战。拆分服务是一项具备艺术的行为，因其本身就没有一个具体、良好的定义的模板或者算法来协助我们的拆分工作。&lt;/p>
&lt;p>分布式系统带来的各种复杂性。采用这项模式之后，我们依然需要考虑它的复杂性，比如测试、事务、部署模式、通讯、网关、服务发现、可靠性、安全，可观测性（日志、审计、跟踪，健康检查）等等一系列额外的任务需要做。&lt;/p>
&lt;h3 id="微服务拆分原则">微服务拆分原则&lt;/h3>
&lt;p>在我看来，微服务拆分其实目前来说没有确定的原则和标准可以参考，我们进行服务拆分时可以参考以下几个方面：&lt;/p>
&lt;p>按业务功能拆分：将整个系统按照不同的业务模块进行拆分，每个模块对应一个微服务。这种方式能够有效地降低系统的复杂度，提高系统的可维护性和可扩展性。&lt;/p>
&lt;p>按数据拆分：将整个系统的数据按照不同的领域进行拆分，每个领域对应一个微服务。这种方式能够提高系统的性能和可扩展性。&lt;/p>
&lt;p>按用户界面拆分：将整个系统按照不同的用户界面进行拆分，每个用户界面对应一个微服务。这种方式能够实现快速迭代和响应用户需求的能力。&lt;/p>
&lt;p>按技术栈拆分：将整个系统按照不同的技术栈进行拆分，每个技术栈对应一个微服务。这种方式能够提高开发效率和降低系统的复杂度。&lt;/p>
&lt;p>按性能拆分：将整个系统按照不同的性能需求进行拆分，每个需求对应一个微服务。这种方式能够提高系统的性能和可扩展性。&lt;/p>
&lt;h2 id="rpc">RPC&lt;/h2>
&lt;h3 id="什么是rpc">什么是RPC&lt;/h3>
&lt;p>&lt;img src="https://github.com/LanshanTeam/Courseware-Backend-Go-2022/raw/main/class11-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8ERPC%E6%A1%86%E6%9E%B6/images/rpc.jpg" alt="img">&lt;/p>
&lt;p>RPC是指远程过程调用,是Remote Procedure Call三个单词的缩写，功能就是本地的函数一样去调远程函数，远程一般是指通过网络从远程计算机程序上请求服务，也可以在在宿主机下通过网络进行不同架构下的互相请求服务。&lt;/p>
&lt;p>RPC在分布式或者微服务架构上非常常用，RPC让不同服务之间的服务调用像本地调用一样简单高效，RPC是一种网络协议，是一种规范，每个大厂几乎都有自己研发的RPC协议。&lt;/p>
&lt;h3 id="为什么要用rpc">为什么要用RPC&lt;/h3>
&lt;p>如果我们开发简单的单一应用，逻辑简单、用户不多、流量不大，那我们用不着。&lt;/p>
&lt;p>当我们的系统访问量增大、业务增多时，我们会发现一台单机运行此系统已经无法承受。此时，我们可以将业务拆分成几个互不关联的应用，分别部署在各自机器上，以划清逻辑并减小压力。此时，我们也可以不需要RPC，因为应用之间是互不关联的。&lt;/p>
&lt;p>当我们的业务越来越多、应用也越来越多时，自然的，我们会发现有些功能已经不能简单划分开来或者划分不出来。此时，可以将公共业务逻辑抽离出来，将之组成独立的服务Service应用 。而原有的、新增的应用都可以与那些独立的Service应用 互，以此来完成完整的业务功能。&lt;/p>
&lt;p>所以此时，我们急需一种高效的应用程序之间的通讯手段来完成这种需求，服务之间的调用需要各种场景和因素的考虑，内部原理非常复杂和繁琐，同时在集群情况下，服务的负载均衡，熔断，限流等都是需要去考虑的，这时候就需要一个集服务注册发现、负载均衡、序列化协议、RPC通信协议、Socket通信、异步调用、熔断降级等技术为一体的技术去完成这些公共功能，所以你看，RPC大显身手的时候来了！&lt;/p>
&lt;p>其实描述的场景也是服务化 、微服务和分布式系统架构的基础场景。即RPC框架就是实现以上结构的有力方式。&lt;/p></description></item><item><title>Go-zero 微服务</title><link>https://example.org/docs/lesson14/lesson14/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson14/lesson14/</guid><description>&lt;h1 id="go-zero-快速搭建微服务demo">Go-zero 快速搭建微服务demo&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>我认为框架的学习，快速搭建微服务demo，看官方文档自己摸索足矣，主要讲一些踩坑经验和进阶的学习&lt;/p>
&lt;h2 id="官方文档必看">官方文档（必看）！！！&lt;/h2>
&lt;p>直接看快速开始，跟着做就可以了&lt;/p>
&lt;p>&lt;a href="https://go-zero.dev/">https://go-zero.dev/&lt;/a>&lt;/p>
&lt;h2 id="社区群里面大佬多不懂的可以去问一下">社区群（里面大佬多，不懂的可以去问一下）&lt;/h2>
&lt;p>&lt;a href="https://go-zero.dev/docs/reference/about-us">https://go-zero.dev/docs/reference/about-us&lt;/a>&lt;/p>
&lt;h2 id="项目推荐">项目推荐&lt;/h2>
&lt;p>如果快速开始过了之后，能搭建一个小demo，那么就可以看大佬们的项目深入学习啦，这里我推荐两个，一个是looklook，可以学习一些规范和很多技术栈，包括链路追踪用的jeager。日志收集然后可视化呈现的elk，云原生监控prometheus，k8s&amp;hellip;.. 再一个就是电商项目lebron，这个对业务的学习是很有帮助的，尤其是秒杀那一块，能学到很多高并发处理手段。&lt;/p>
&lt;h3 id="lookook规范技术栈">lookook(规范&amp;amp;&amp;amp;技术栈)&lt;/h3>
&lt;blockquote>
&lt;p>项目地址：https://github.com/Mikaelemmmm/go-zero-looklook&lt;/p>
&lt;p>LookLook文档地址：https://github.com/Mikaelemmmm/go-zero-looklook/tree/main/doc/chinese&lt;/p>&lt;/blockquote>
&lt;h3 id="lebron业务处理高并发设计">lebron（业务处理&amp;amp;&amp;amp;高并发设计）&lt;/h3>
&lt;blockquote>
&lt;p>项目地址：https://github.com/zhoushuguang/lebron&lt;/p>
&lt;p>系列博客：https://learnku.com/articles/68472&lt;/p>&lt;/blockquote>
&lt;h2 id="一些视频教学">一些视频教学&lt;/h2>
&lt;p>looklook作者讲解的入门教学视频，可以看一下&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1LS4y1U72n/?spm_id_from=333.788&amp;amp;vd_source=23d8be6eab81d2d14531293e81d6a5dc">go-zero入门视频&lt;/a>&lt;/p>
&lt;p>go-zero分布式缓存设计，这个万总讲的很好，&lt;strong>必看&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1Rv411L72P/?spm_id_from=333.337.search-card.all.click&amp;amp;vd_source=23d8be6eab81d2d14531293e81d6a5dc">go-zero分布式缓存设计&lt;/a>&lt;/p>
&lt;h2 id="一些tips">一些tips&lt;/h2>
&lt;h3 id="并发神器mr包">并发神器mr包&lt;/h3>
&lt;p>可以用mr.Finish()去并发rpc请求，相当于封装好的goroutine&lt;/p>
&lt;p>还有MapReduce，也值得学习一些，下面有讲解文章可以看看&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/7031483035820556295">https://juejin.cn/post/7031483035820556295&lt;/a>&lt;/p>
&lt;p>视频推荐：https://www.bilibili.com/video/BV1eQ4y1W7PV?p=4&amp;amp;vd_source=23d8be6eab81d2d14531293e81d6a5dc&lt;/p>
&lt;p>这个佬的视频都可以看，&lt;strong>很硬核很低层&lt;/strong>&lt;/p>
&lt;h3 id="go-zero实现的分布式锁">go-zero实现的分布式锁&lt;/h3>
&lt;p>&lt;a href="https://go-zero.dev/docs/tutorials/redis/redis-lock">官方文档demo&lt;/a>&lt;/p>
&lt;p>博客解读源码实现&lt;/p>
&lt;p>&lt;a href="https://juejin.cn/post/7026544325030838303">https://juejin.cn/post/7026544325030838303&lt;/a>&lt;/p>
&lt;p>视频推荐：https://www.bilibili.com/video/BV1Pm4y1b76u?p=1&amp;amp;vd_source=23d8be6eab81d2d14531293e81d6a5dc&lt;/p>
&lt;p>这里有介绍etcd实现的，很值得看看&lt;/p>
&lt;h2 id="作业">作业&lt;/h2>
&lt;ul>
&lt;li>Lv1 用go-zero随便写个服务demo&lt;/li>
&lt;li>Lv2 把looklook和lebron过一遍&lt;/li>
&lt;li>LvX 自己深入go-zero的一些底层设计实现源码、按照自己的兴趣广泛深入发展，重点是&lt;strong>深入&lt;/strong>&amp;hellip;&amp;hellip;&lt;/li>
&lt;/ul></description></item><item><title>第十五课</title><link>https://example.org/docs/lesson15/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson15/readme/</guid><description>&lt;h2 id="架构设计">架构设计&lt;/h2>
&lt;p>在前两节课当中，相信大家都熟悉了微服务，但是微服务并不是万金油，通常会带来更高的维护成本和更复杂的架构设计难度，如果架构设计的不好，那么很容易就会写成屎山，也不能充分发挥微服务的优势。&lt;/p>
&lt;p>传统企业应用大多是单体架构，而单体架构则大多是三层架构。三层架构解决了程序内代码间调用复杂、代码职责不清的问题，但这种分层是逻辑概念，在物理上它是中心化的集中式架构，并不适合分布式微服务架构。&lt;/p>
&lt;p>DDD 分层架构中的要素其实和三层架构类似，只是在 DDD 分层架构中，这些要素被重新归类，重新划分了层，确定了层与层之间的交互规则和职责边界。&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/qq_16498553/article/details/110848831">什么是 DDD&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/DDD%E5%AE%9E%E6%88%98%E8%AF%BE">DDD 实战课&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson15/java_error_in_idea.png" alt="img">&lt;/p>
&lt;p>DDD 分层架构在用户接口层引入了 DTO，给前端提供了更多的可使用数据和更高的展示灵活性。&lt;/p>
&lt;p>DDD 分层架构对三层架构的业务逻辑层进行了更清晰的划分，改善了三层架构核心业务逻辑混乱，代码改动相互影响大的情况。DDD 分层架构将业务逻辑层的服务拆分到了应用层和领域层。应用层快速响应前端的变化，领域层实现领域模型的能力。&lt;/p>
&lt;p>另外一个重要的变化发生在数据访问层和基础层之间。三层架构数据访问采用 DAO 方式；DDD 分层架构的数据库等基础资源访问，采用了仓储（Repository）设计模式，通过依赖倒置实现各层对基础资源的解耦。&lt;/p>
&lt;p>如何判断微服务设计是否合理呢？其实很简单，只需要看它是否满足这样的情形就可以了：随着业务的发展或需求的变更，在不断重新拆分或者组合成新的微服务的过程中，不会大幅增加软件开发和维护的成本，并且这个架构演进的过程是非常轻松、简单的。&lt;/p>
&lt;p>这也是微服务设计的重点，就是看微服务设计是否能够支持架构长期、轻松的演进。&lt;/p>
&lt;h3 id="微服务还是小单体">&lt;strong>微服务还是小单体？&lt;/strong>&lt;/h3>
&lt;p>有些项目团队在将集中式单体应用拆分为微服务时，首先进行的往往不是建立领域模型，而只是按照业务功能将原来单体应用的一个软件包拆分成多个所谓的“微服务”软件包，而这些“微服务”内的代码仍然是集中式三层架构的模式，“微服务”内的代码高度耦合，逻辑边界不清晰，这里我们暂且称它为“小单体微服务”。&lt;/p>
&lt;p>下面这张图也很好地展示了这个过程。&lt;/p>
&lt;p>而随着新需求的提出和业务的发展，这些小单体微服务会慢慢膨胀起来。当有一天你发现这些膨胀了的微服务，有一部分业务功能需要拆分出去，或者部分功能需要与其它微服务进行重组时，你会发现原来这些看似清晰的微服务，不知不觉已经摇身一变，变成了臃肿油腻的大单体了，而这个大单体内的代码依然是高度耦合且边界不清的。&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson15/1280X1280.PNG" alt="img">
“辛辛苦苦好多年，一夜回到解放前啊！”这个时候你就需要一遍又一遍地重复着从大单体向单体微服务重构的过程。想想，这个代价是不是有点高了呢？&lt;/p>
&lt;p>其实这个问题已经很明显了，那就是边界。&lt;/p>
&lt;p>这种单体式微服务只定义了一个维度的边界，也就是微服务之间的物理边界，本质上还是单体架构模式。微服务设计时要考虑的不仅仅只有这一个边界，别忘了还要定义好微服务内的逻辑边界和代码边界，这样才能得到你想要的结果。&lt;/p>
&lt;p>那现在你知道了，我们一定要避免将微服务设计为小单体微服务，那具体该如何避免呢？清晰的边界人人想要，可该如何保证呢？DDD 已然给出了答案。&lt;/p>
&lt;p>微服务的拆分可以参考领域模型，也可以参考聚合，因为聚合是可以拆分为微服务的最小单位的。但实施过程是否一定要做到逻辑边界与物理边界一致性呢？也就是说聚合是否也一定要设计成微服务呢？答案是不一定的，这里就涉及到微服务过度拆分的问题了。&lt;/p>
&lt;p>微服务的过度拆分会使软件维护成本上升，比如：集成成本、发布成本、运维成本以及监控和定位问题的成本等。在项目建设初期，如果你不具备较强的微服务管理能力，那就不宜将微服务拆分过细。当我们具备一定的能力以后，且微服务内部的逻辑和代码边界也很清晰，你就可以随时根据需要，拆分出新的微服务，实现微服务的架构演进了。&lt;/p>
&lt;p>当然，还要记住一点，微服务内聚合之间的服务调用和数据依赖需要符合高内聚松耦合的设计原则和开发规范，否则你也不能很快完成微服务的架构演进。&lt;/p>
&lt;p>&lt;img src="https://example.org/images/lesson15/1280X1280%20(1).PNG" alt="img">&lt;/p>
&lt;h3 id="微服务设计原则">&lt;strong>微服务设计&lt;/strong>原则&lt;/h3>
&lt;p>微服务设计原则中，如高内聚低耦合、复用、单一职责等这些常见的设计原则在此就不赘述了，主要强调下面这几条：&lt;/p>
&lt;p>&lt;strong>第一条：要领域驱动设计&lt;/strong>，而不是数据驱动设计，也不是界面驱动设计。&lt;/p>
&lt;p>微服务设计首先应建立领域模型，确定逻辑和物理边界以及领域对象后，然后才开始微服务的拆分和设计。而不是先定义数据模型和库表结构，也不是前端界面需要什么，就去调整核心领域逻辑代码。在设计时应该将外部需求从外到内逐级消化，尽量降低对核心领域层逻辑的影响。&lt;/p>
&lt;p>&lt;strong>第二条：要边界清晰的微服务，而不是泥球小单体。&lt;/strong>&lt;/p>
&lt;p>微服务上线后其功能和代码也不是一成不变的。随着需求或设计变化，领域模型会迭代，微服务的代码也会分分合合。边界清晰的微服务，可快速实现微服务代码的重组。微服务内聚合之间的领域服务和数据库实体原则上应杜绝相互依赖。你可通过应用服务编排或者事件驱动，实现聚合之间的解耦，以便微服务的架构演进。&lt;/p>
&lt;p>&lt;strong>第三条：要职能清晰的分层，而不是什么都放的大箩筐。&lt;/strong>&lt;/p>
&lt;p>分层架构中各层职能定位清晰，且都只能与其下方的层发生依赖，也就是说只能从外层调用内层服务，内层通过封装、组合或编排对外逐层暴露，服务粒度也由细到粗。应用层负责服务的组合和编排，不应有太多的核心业务逻辑，领域层负责核心领域业务逻辑的实现。各层应各司其职，职责边界不要混乱。在服务演进时，应尽量将可复用的能力向下层沉淀。&lt;/p>
&lt;p>&lt;strong>第四条：要做自己能 hold 住的微服务，而不是过度拆分的微服务。&lt;/strong>&lt;/p>
&lt;p>微服务过度拆分必然会带来软件维护成本的上升，比如：集成成本、运维成本、监控和定位问题的成本。企业在微服务转型过程中还需要有云计算、DevOps、自动化监控等能力，而一般企业很难在短时间内提升这些能力，如果项目团队没有这些能力，将很难 hold 住这些微服务。&lt;/p>
&lt;p>如果在微服务设计之初按照 DDD 的战略设计方法，定义好了微服务内的逻辑边界，做好了架构的分层，其实我们不必拆分太多的微服务，即使是单体也未尝不可。随着技术积累和能力提升，当我们有了这些能力后，由于应用内有清晰的逻辑边界，我们可以随时轻松地重组出新的微服务，而这个过程不会花费太多的时间和精力。&lt;/p>
&lt;h2 id="服务注册与发现">服务注册与发现&lt;/h2>
&lt;h3 id="什么是服务注册与发现">什么是服务注册与发现？&lt;/h3>
&lt;p>一个后台系统，存在两个服务 A 和 B， A 服务需要调用 B 服务，就需要建立和 B 服务的连接，通常需要 B 服务的地址。&lt;/p>
&lt;p>在计算机领域，服务的地址通常是由 ip 地址 和 端口 port 来组合表达。&lt;/p></description></item><item><title>负载均衡</title><link>https://example.org/docs/lesson16/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson16/readme/</guid><description>&lt;h1 id="第十六节课">第十六节课&lt;/h1>
&lt;h3 id="负载均衡">负载均衡&lt;/h3>
&lt;hr>
&lt;p>负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是 尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。&lt;/p>
&lt;p>&lt;strong>负载均衡的主要作用如下：&lt;/strong>&lt;/p>
&lt;p>**高并发：**负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。&lt;/p>
&lt;p>**伸缩性：**添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。&lt;/p>
&lt;p>**高可用：**负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。&lt;/p>
&lt;h3 id="反向代理">反向代理&lt;/h3>
&lt;hr>
&lt;p>反向代理（Reverse Proxy）方式是指以 代理服务器 来接受网络请求，然后 将请求转发给内网中的服务器，并将从内网中的服务器上得到的结果返回给网络请求的客户端。&lt;/p>
&lt;p>与反向代理相对的就是正向代理。&lt;/p>
&lt;p>正向代理：发生在 &lt;strong>客户端&lt;/strong>，是由用户主动发起的。vpn软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。&lt;/p>
&lt;p>反向代理：发生在 &lt;strong>服务端&lt;/strong>，用户不知道代理的存在。&lt;/p>
&lt;p>nginx就是反向代理的一个主流产品。&lt;/p>
&lt;h3 id="限流-熔断-降级">限流 熔断 降级&lt;/h3>
&lt;hr>
&lt;p>在分布式系统中，&lt;strong>熔断&lt;/strong>、&lt;strong>限流&lt;/strong>和&lt;strong>服务降级&lt;/strong>是关键的容错设计模式，用于保护系统免受突发流量、故障或性能问题的影响。&lt;/p>
&lt;p>让我们深入了解这些概念：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>限流&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当系统的处理能力无法应对外部请求的突发流量时，为了避免系统崩溃，必须采取限流措施。&lt;/li>
&lt;li>限流指标可以是：
&lt;ul>
&lt;li>&lt;strong>TPS&lt;/strong>（每秒事务数）：按事务完成数量来限制流量。&lt;/li>
&lt;li>&lt;strong>HPS&lt;/strong>（每秒请求数）：服务端每秒收到的客户端请求数量。&lt;/li>
&lt;li>&lt;strong>QPS&lt;/strong>（每秒查询请求数）：服务端每秒响应的客户端查询数量。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>常用的限流方法包括流量计数器、滑动时间窗口、漏桶算法和令牌桶算法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>熔断&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>当流量过大或下游服务出现问题时，熔断会自动断开与下游服务的交互，以避免影响整个系统。&lt;/li>
&lt;li>熔断可以自我恢复，通过自我诊断下游系统是否已修复或上游流量是否减少至正常水平来判断。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>服务降级&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>降级是从系统内部的平级服务或业务维度考虑，用于保护其他正常使用的功能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当服务出现问题或影响核心流程性能时，需要暂时屏蔽掉，待高峰或问题解决后再打开。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>3者的关系这样理解：
拿下棋比喻：
限流： 相当于尽量避免同时和两三个人同时下
熔断：相当于你的一颗卒被围死了，就不要利用其它棋去救它了，弃卒保帅，否则救他的棋也可能被拖死
降级：相当于尽量不要走用处不大的棋了，浪费走棋机会（资源），使已经过河的棋有更多的走棋机会（资源）发挥最大作用&lt;/p>&lt;/blockquote>
&lt;p>kitex中使用 &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/service-governance/loadbalance/">负载均衡&lt;/a> &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/service-governance/circuitbreaker/">熔断&lt;/a> &lt;a href="https://www.cloudwego.io/zh/docs/kitex/tutorials/service-governance/limiting/">限流&lt;/a>&lt;/p>
&lt;p>&lt;strong>Sentinel&lt;/strong> 是一款面向分布式服务架构的轻量级流量控制产品&lt;/p>
&lt;p>Sentinel 的主要特点：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>流量控制&lt;/strong>：Sentinel 可以限制外部请求的流量，防止系统因突发流量而崩溃。&lt;/li>
&lt;li>&lt;strong>实时监控&lt;/strong>：它提供实时监控功能，您可以在控制台中查看接入应用的运行情况。&lt;/li>
&lt;li>&lt;strong>开源生态&lt;/strong>：Sentinel 可以与其他开源框架/库（如 Spring Cloud、Dubbo、gRPC）整合。&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://sentinelguard.io/zh-cn/docs/golang/quick-start.html">sentinel文档&lt;/a>&lt;/p>
&lt;h3 id="nginx">Nginx&lt;/h3>
&lt;hr>
&lt;p>Nginx是一个高性能、开源的HTTP服务器和反向代理服务器。它可以作为一个独立的Web服务器，也可以作为其他Web服务器的反向代理。Nginx以其出色的性能和高度的可扩展性而闻名，是许多高流量网站的首选服务器。&lt;/p>
&lt;p>Nginx的特点包括：&lt;/p>
&lt;ul>
&lt;li>高性能：Nginx采用事件驱动的方式处理请求，可以处理大量的并发请求。&lt;/li>
&lt;li>可扩展性：Nginx可以通过添加模块来扩展其功能，支持各种第三方模块。&lt;/li>
&lt;li>反向代理：Nginx可以作为反向代理服务器，可以隐藏真实服务器的地址，从而提高网络安全性。&lt;/li>
&lt;li>负载均衡：Nginx可以实现负载均衡，可以将请求分配到多个服务器上，从而提高网站的性能和可靠性。&lt;/li>
&lt;/ul>
&lt;p>Nginx是一个功能强大而灵活的服务器，适合用于构建高性能、可扩展的Web应用程序。&lt;/p>
&lt;p>在Nginx中实现反向代理非常简单。只需要在Nginx配置文件中添加一个&lt;code>proxy_pass&lt;/code>指令即可。例如，要将所有&lt;code>/api&lt;/code>请求代理到&lt;code>http://localhost:3000&lt;/code>，可以使用以下配置：&lt;/p>
&lt;pre tabindex="0">&lt;code>location /api {
 proxy_pass &amp;lt;http://localhost:3000&amp;gt;;
}
&lt;/code>&lt;/pre>&lt;p>这将使Nginx将所有&lt;code>/api&lt;/code>请求代理到&lt;code>http://localhost:3000&lt;/code>。在这个例子中，Nginx充当了客户端和服务器之间的中转站，将所有请求代理到真实的服务器上，然后将响应返回给客户端。&lt;/p></description></item><item><title>第十七课</title><link>https://example.org/docs/lesson17/%E5%90%8E%E7%AB%AF-go-%E7%AC%AC%E5%8D%81%E4%B8%83%E6%AC%A1%E8%AF%BE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson17/%E5%90%8E%E7%AB%AF-go-%E7%AC%AC%E5%8D%81%E4%B8%83%E6%AC%A1%E8%AF%BE/</guid><description>&lt;h2 id="可观测性">可观测性&lt;/h2>
&lt;h3 id="什么是可观测性">什么是可观测性？&lt;/h3>
&lt;p>在计算机系统和软件领域，可观测性的含义是：可以从系统和应用对外输出的信息（指标、日志和链路），来帮助我们了解应用程序的内部系统状态和运行情况。&lt;/p>
&lt;p>但可观测性并不只是简单的数据采集，它更强调对这些数据的&lt;strong>关联和分析&lt;/strong>，这能够帮助我们&lt;strong>快速定位&lt;/strong>，找到问题的根本原因。当然，最终的目的是&lt;strong>保障系统的可靠性，达到服务质量的目标&lt;/strong>。&lt;/p>
&lt;h3 id="为什么需要可观测性">为什么需要可观测性？&lt;/h3>
&lt;p>软件架构从单体应用到三层架构（前端 Web，应用 App 层，以及后端的数据库），再到现在的微服务架构，无疑是越来越复杂了。分布式架构具有可扩展性、可维护性、灵活性等多种优点，但是这种部署方案也出现一些问题：&lt;/p>
&lt;p>1、排查问题难度大，周期长
2、特定场景难复现
3、系统性能瓶颈分析较难&lt;/p>
&lt;p>以前针对简单的系统架构，常用的维护手段还是建立监控，然后制作一些仪表盘来展示各个层面指标的情况，再加上一些告警对各种指标的阈值进行监控和通知，但是现在，不仅排查故障的难度越来越大，错误还有了更多潜在的组合，传统的排障方式越来越没有效率。所以复杂性的增加使得我们越来越有必要为系统和应用构建可观测性。&lt;/p>
&lt;p>假设现在你运营一个分布式的电商平台下，这个项目的订单处理涉及多个微服务和数据库（用户服务、支付服务、购物车服务等等）。如果订单处理的调用链路上某个服务出现故障或者延迟，导致订单处理失败或者变慢，进而影响客户体验，那么这个问题究竟是出在哪个服务上呢？如果没有良好的观测机制，就无法追踪整个订单处理事务的全过程，因而很难定位到问题。&lt;/p>
&lt;p>这种情况下，如果通过实时监控系统，就可以追踪到订单的处理流程，识别潜在的瓶颈或故障点，及时进行调整和修复。&lt;/p>
&lt;h3 id="可观测性指标日志链路追踪">可观测性=指标+日志+链路追踪？&lt;/h3>
&lt;p>指标（metrics），日志（logs）和链路追踪（Tracing）是可观测性的三大支柱，先来看看它们的含义：&lt;/p>
&lt;h4 id="metrics">Metrics&lt;/h4>
&lt;p>&lt;strong>是在⼀段时间内测量的数值&lt;/strong>。它包括特定属性，例如时间戳、名称、键和值。和⽇志不同，指标在默认情况下是结构化的，这会让查询和优化存储变得更加容易。&lt;/p>
&lt;p>例如：2022/05/20 12:48:22，CPU usage user，23.87%，它就表示 CPU 运行在用户态的时间占比在这一刻为 23.87%。&lt;/p>
&lt;h4 id="logs">Logs&lt;/h4>
&lt;p>&lt;strong>日志：是对特定时间发生的事件的文本记录&lt;/strong>。日志一般是非结构化字符串，会在程序执行期间被写入磁盘。每个请求会产生一行或者多行的日志，每个日志行可能包含 1-5 个维度的有用数据（例如客户端 IP，时间戳，调用方法，响应码等等）。当系统出现问题时，⽇志通常也是排错⾸先查看的地⽅。&lt;/p>
&lt;h4 id="traces">Traces&lt;/h4>
&lt;p>&lt;strong>有时候也被称为分布式追踪（Distributed Tracing），表示请求通过分布式系统的端到端的路径&lt;/strong>。当请求通过主机系统时， 它执⾏的每个操作被称为“跨度”（Span）。一个 Trace 是 Spans 的有向无环图。链路追踪一般会通过一个可视化的瀑布图展现出来。瀑布图展示了用于调试的请求的每个阶段，以及每个部分的开始时间和持续时长。&lt;/p>
&lt;p>举个分布式调用的例子：客户端发起请求，请求首先到达负载均衡器，经过认证服务、系统服务，然后请求资源，最终返回结果。&lt;/p>
&lt;p>&lt;img src="img/trace.png" alt="trace">&lt;/p>
&lt;h5 id="trace-实现的基本原理">Trace 实现的基本原理&lt;/h5>
&lt;p>想要实现调用链，就要为&lt;strong>每次调用做个标识&lt;/strong>，然后&lt;strong>将服务按标识大小排列&lt;/strong>，可以更清晰地看出调用顺序，我们暂且将该标识命名为 spanid&lt;/p>
&lt;p>&lt;img src="img/trace1.png" alt="trace1">&lt;/p>
&lt;p>实际场景中，我们需要知道某次请求调用的情况，所以只有spanid还不够，得为&lt;strong>每次请求做个唯一标识&lt;/strong>，这样才能根据标识查出本次请求调用的所有服务，而这个标识我们命名为 traceid。&lt;/p>
&lt;p>&lt;img src="img/trace2.png" alt="trace2">&lt;/p>
&lt;p>现在根据spanid可以轻易地知道被调用服务的先后顺序，但无法体现调用的层级关系，正如下图所示，多个服务可能是逐级调用的链条，也可能是同时被同一个服务调用。例如：&lt;/p>
&lt;p>&lt;img src="img/trace3.png" alt="trace3">&lt;/p>
&lt;p>所以应该每次都记录下是谁调用的，我们用parentid作为这个标识的名字。&lt;/p>
&lt;p>&lt;img src="img/trace4.png" alt="trace4">&lt;/p>
&lt;p>到现在，已经知道调用顺序和层级关系了，但是接口出现问题后，还是不能找到出问题的环节，如果某个服务有问题，那个被调用执行的服务一定耗时很长，要想&lt;strong>计算出耗时&lt;/strong>，上述的三个标识还不够，还需要加上&lt;strong>时间戳&lt;/strong>，时间戳可以更精细一点，精确到微秒级。只记录发起调用时的时间戳还算不出耗时，要记录下服务&lt;strong>返回时的时间戳&lt;/strong>，&lt;strong>才能算出时间差&lt;/strong>&lt;/p>
&lt;p>&lt;img src="img/trace5.png" alt="trace5">&lt;/p>
&lt;p>其实 span 除了上面说的这几个必选参数外，还可以记录一些其他信息，比如发起调用服务名称，被调用服务名称、返回结果、IP 等等。但是这些信息是在 span 内自己上报给 Collector 或者 Backend Server，而不会在链路上传递，在链路上传递的主要是 trace_id 和 span_id 等用于在跨度间建立关系的信息（也就是 &lt;a href="https://opentelemetry.io/docs/concepts/signals/traces/#span-context">Span Context&lt;/a>）。这样子，Collector 或者 Backend Server 就有了一个链路的很多 span，而这些 span 都有 span_id、trace_id，于是就可以通过这些信息构建出一个完整的调用链了。&lt;/p></description></item><item><title>第十八课</title><link>https://example.org/docs/lesson18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson18/%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80/</guid><description>&lt;h2 id="前置知识">前置知识&lt;/h2>
&lt;h3 id="什么是分布式系统">什么是分布式系统&lt;/h3>
&lt;p>分布式就是一群独立的服务集合，相互协调，相互配合，共同对外提供服务&lt;/p>
&lt;p>独立：服务与服务之间存在隔离，往往只通过网络进行通信与协调&lt;/p>
&lt;h3 id="分布式系统的特点">分布式系统的特点&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>多进程&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>并发&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>隔离：如操作系统隔离、网络隔离、时钟隔离&amp;hellip;.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="为什么要分布式系统">为什么要分布式系统&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>高性能&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可扩展&lt;/p>
&lt;/li>
&lt;li>
&lt;p>高可用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>有些场景天然就是分布式的，比如跨行转账&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="分布式系统的挑战">分布式系统的挑战&lt;/h3>
&lt;p>20 世纪 90 年代，L. Peter Deutsch 等人总结出了分布式计算的谬论：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>网络是可靠的&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>延迟为 0&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>带宽是无限的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络是安全的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>拓扑结构不会改变&lt;/p>
&lt;/li>
&lt;li>
&lt;p>传输成本为 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网络是同构的&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>最本质的问题：&lt;/p>
&lt;ul>
&lt;li>不可靠的网络：网络存在延时、丢包、乱序等问题&lt;/li>
&lt;/ul>
&lt;p>由网络引发的问题：&lt;/p>
&lt;ul>
&lt;li>全局时钟难以定义&lt;/li>
&lt;li>数据存在不一致的现象&lt;/li>
&lt;li>并发变得更加复杂，难以控制&lt;/li>
&lt;/ul>
&lt;p>其他问题：&lt;/p>
&lt;ul>
&lt;li>机器宕机&lt;/li>
&lt;/ul>
&lt;h2 id="分布式理论">分布式理论&lt;/h2>
&lt;h3 id="cap-理论">CAP 理论&lt;/h3>
&lt;p>CAP 分为了三部分，分别代表了在一个分布式系统的三个指标&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Consistency&lt;/strong> (一致性)：强调数据的正确性，要求各节点提供的数据都是一致准确的&lt;/li>
&lt;li>&lt;strong>Availability&lt;/strong> (可用性)：要求系统的可用性高，例如不能出现让用户长时等待的情况&lt;/li>
&lt;li>&lt;strong>Partition Tolerance&lt;/strong> (分区容错性)：在发生分区时（如某一个节点网络连不上了），要求系统仍然能够正常运作&lt;/li>
&lt;/ul>
&lt;p>CAP 理论：在一个系统中，至多同时满足 CAP 中的两个。
对于分布式系统而言，P 是必须要保证的，所以分布式系统其实就分为了 CP，AP 两种类型&lt;/p>
&lt;ul>
&lt;li>CP：保证数据一致性的情况下可能牺牲系统的可用性&lt;/li>
&lt;li>AP：保证用户体验好，但可能出现数据不一致的情况&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://example.org/images/lesson18/cap.png" alt="">&lt;/p>
&lt;p>C A P 三者都完美满足的分布式系统是不存在的&lt;/p>
&lt;p>网络分区是无法避免的，P 是分布式系统必须要保证的，故可以将分布式系统分为 CP、AP 两类&lt;/p>
&lt;p>C 与 A 不是绝对的，应该是在具体的业务场景下，将 C 和 A 达到一个平衡的状态&lt;/p></description></item><item><title/><link>https://example.org/docs/lesson09/example2/baidu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://example.org/docs/lesson09/example2/baidu/</guid><description>&lt;!DOCTYPE html>
&lt;html lang="ch">
&lt;head>
 &lt;meta charset="UTF-8">
 &lt;meta http-equiv="X-UA-Compatible" content="IE=edge">
 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
 &lt;title>百度一下，你就知道&lt;/title>
 &lt;style>
 .left {
 background-color: white;
 float: left;
 width: 55px;
 height: 55px;
 line-height: 47px;
 font-size: 13.2px;
 text-align: center;
 cursor: pointer; /*鼠标变小手*/
 }
 .right-cd {
 background-color: white;
 width: 55px;
 height: 55px;
 line-height: 47px;
 font-size: 13.2px;
 text-align: center;
 position: absolute;
 top: 10px;
 right: 350px;
 cursor: pointer;
 }
 .bdimg {
 position: absolute;
 /*绝对位移*/
 left: 610px;
 /*left 属性规定元素的左边缘。该属性定义了定位元素左外边距边界与其包含块左边界之间的偏移。*/
 top: 50px;
 /*top 属性规定元素的顶部边缘。该属性定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。*/
 }
 .ittable {
 width: 600px;
 height: 38px;
 color: black;
 margin:2px 0 0 20px;
 border:2px solid #DBDBDB;
 border-radius:8px;
 position: absolute;
 left: 400px;
 top: 220px;
 padding-left: 18px;
 }
 .bdbutton {
 background-color: #4e6ef2;
 color: white;
 border:0 solid white;
 border-radius: 0 10px 10px 0;/* 左平右圆*/
 width: 100px;
 height: 44px;
 font-size: 16px;
 }
 .bdbutton-wrap {
 background-color: #4e6ef2;
 color: white;
 border: 0 solid white;
 border-radius: 0 10px 10px 0;/* 左平右圆*/
 width: 100px;
 height: 44px;
 position: absolute;
 left: 1018px;
 top: 222px;
 font-size: 16px;
 }
 .input_move{
 background-color: royalblue;
 color: white;
 border: 0 solid white;
 border-radius: 0 10px 10px 0;/* 左平右圆*/
 width: 100px;
 height: 44px;
 font-size: 16px;
 }
 input[type=text]:focus{
 outline: none;
 border: 2px solid #4e6ef2;
 padding-left:18px; /*左边距*/
 }
 input[type=submit]{
 outline: none;
 cursor: pointer;
 }
 .caimg {
 width: 50px;
 height: 50px;
 position: absolute;
 top: 220px;
 left: 965px;
 cursor: pointer;
 }
 .a2png {
 width: 30px;
 height: 30px;
 line-height: 47px;
 text-align: center;
 position: absolute;
 top: 20px;
 right: 320px;
 cursor: pointer;
 }
 .right-36 {
 width: 55px;
 height: 55px;
 line-height: 47px;
 font-size: 13.2px;
 text-align: center;
 position: absolute;
 top: 12px;
 right: 275px;
 cursor: pointer;
 }
 .air-con {
 width: 30px;
 height: 20px;
 line-height: 21px;/*文字下划线位置*/
 font-size: 13px;
 color: white;
 text-align: center;
 position: absolute;
 top: 25px;
 right: 250px;
 cursor: pointer;
 border-radius: 8px 8px 8px 8px;
 background-color: yellowgreen;
 }
 .sz {
 width: 55px;
 height: 55px;
 line-height: 47px;
 font-size: 13.2px;
 text-align: center;
 position: absolute;
 top: 12px;
 right: 180px;
 cursor: pointer;
 }
 .list-sz{
 width: 75px;
 height: 280px;
 line-height: 30px;
 font-size: 13px;
 text-align: center;
 position: absolute;
 top: 50px;
 right: 170px;
 cursor: pointer;
 -moz-box-shadow: 2px 2px 10px darkgray;
 -webkit-box-shadow: 2px 2px 10px darkgray;
 box-shadow:2px 2px 10px darkgray;
 border-radius: 10px 10px 10px 10px;
 padding: 10px;
 }
 .szf-black{
 color: black;
 }
 .szf-black:hover{ /*伪类鼠标悬停变色*/
 color: dodgerblue;
 }
 .i{
 display:block;
 background:#f00;
 border-radius:3px 3px 3px 3px;
 width:5px;
 height:5px;
 position:relative;
 top: -21px;
 left: 71px;
 }
 .pic{
 width: 25px;
 height: 25px;
 line-height: 47px;
 font-size: 13.2px;
 text-align: center;
 position: absolute;
 top: 19px;
 right: 140px;
 cursor: pointer;
 border-radius: 20px 20px 20px 20px;
 border: 1px solid #4e6ef2;
 padding: 2px;
 background-color: white;

 }
 .account{
 width: 30px;
 height: 30px;
 line-height: 40px;
 font-size: 13.2px;
 text-align: center;
 position: absolute;
 top: 15px;
 right: 100px;
 cursor: pointer;
 }
 .list-account{
 width: 80px;
 height: 125px;
 line-height: 30px;
 font-size: 13px;
 text-align: center;
 position: absolute;
 top: 45px;
 padding: 5px;
 right: 49px;
 cursor: pointer;
 -moz-box-shadow: 2px 2px 10px darkgray;
 -webkit-box-shadow: 2px 2px 10px darkgray;
 box-shadow:2px 2px 10px darkgray;
 border-radius: 10px 10px 10px 10px;
 }
 .weather-box{
 width: 525px;
 height: 270px;
 position: absolute;
 top: 50px;
 right: 45px;
 -moz-box-shadow: 2px 2px 10px darkgray;
 -webkit-box-shadow: 2px 2px 10px darkgray;
 box-shadow:2px 2px 10px darkgray;
 border-radius: 10px 10px 10px 10px;
 text-align: center;
 background-color: white;
 }
 .ma-top{
 margin-top: 10px;
 }
 .change{
 width: 30px;
 height: 25px;
 position: absolute;
 top: 400px;
 right: 250px;
 cursor: pointer;
 }
 .change-ft{
 width: 50px;
 height: 25px;
 position: absolute;
 top: 405px;
 right: 200px;
 cursor: pointer;
 font-size: 13.2px;
 color: gray;
 }


 &lt;/style>
&lt;/head>
&lt;body>
&lt;span class="left">新闻&lt;/span>
&lt;span class="left">hao123&lt;/span>
&lt;span class="left">地图&lt;/span>
&lt;span class="left">贴吧&lt;/span>
&lt;span class="left">视频&lt;/span>
&lt;span class="left">图片&lt;/span>
&lt;span class="left">网盘&lt;/span>
&lt;span class="left">更多&lt;/span>

&lt;img src="https://i.328888.xyz/2022/12/15/44fVN.png" width="300px" height="140px" class="bdimg">

&lt;input type="text" class="ittable">

&lt;div title="按图片搜索"> &lt;!--悬停提示-->
 &lt;img src="carm-baidu-black.png" class="caimg" id="caimg">
&lt;/div>


&lt;label class="bdbutton-wrap">
 &lt;input class="bdbutton" type="submit" onmousemove="this.className='input_move'"
 onmouseout="this.className='bdbutton'" value="百度一下"
 onclick="window.open('https://www.baidu.com')">
&lt;/label>
&lt;div onclick="window.open('https://www.baidu.com/s?tn=baidutop10&amp;rsv_idx=2&amp;wd=%E6%88%90%E9%83%BD%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5')"
 id="o5">
 &lt;div class="right-cd">成都&lt;/div>
 &lt;img src="a2.png" class="a2png">
 &lt;div class="right-36">36℃&lt;/div>
 &lt;div class="air-con">良&lt;/div>
&lt;/div>
&lt;div id="o6" class="weather-box">
 &lt;img src="https://i.328888.xyz/2022/12/15/4446d.png" width="525px" height="250px" class="ma-top">
&lt;/div>

&lt;div id="o1" class="sz">设置&lt;/div>
&lt;div id="o2" class="list-sz">
 &lt;div class="szf-black">搜索设置&lt;/div>
 &lt;div class="szf-black">高级搜索&lt;/div>
 &lt;div class="szf-black">关闭预测&lt;/div>
 &lt;div class="szf-black">隐私设置&lt;/div>
 &lt;div class="szf-black">开启播报&lt;/div>
 &lt;div class="szf-black">关闭播报&lt;/div>
 &lt;div class="szf-black">隐藏咨询&lt;/div>
 &lt;div class="szf-black">关闭播报&lt;/div>
 &lt;hr width="70%" color="darkgray" size="0.5%">
 &lt;div class="szf-black">更换皮肤&lt;span class="i">&lt;/span>&lt;/div>
&lt;/div>
&lt;img src="tx.png" class="pic">
&lt;div class="account" id="o3">Luckyboi&lt;/div>
&lt;div id="o4" class="list-account">
 &lt;div class="szf-black">个人中心&lt;/div>
 &lt;div class="szf-black">账户设置&lt;/div>
 &lt;div class="szf-black">切换账号&lt;/div>
 &lt;div class="szf-black">退出登录&lt;/div>
&lt;/div>

&lt;img src="https://i.328888.xyz/2022/12/15/44iSo.png" class="change" id="change-img">
&lt;div class="change-ft" onclick="RtChangeImg()">换一换&lt;/div>

&lt;/body>
&lt;script>
 //照相机变色
 var img=document.getElementById("caimg")
 img.onmousemove=function () {
 img.src = "carm-baidu-blue.png"
 }
 img.onmouseout=function (){
 img.src="carm-baidu-black.png"
 }

 //换一换-点击旋转
 var chimg=document.getElementById("change-img")
 chimg.onclick=RtChangeImg=function (){
 chimg.style.transform="rotate(180deg)"
 chimg.style.transition="0.3s"
 sleep(300).then(() => {
 chimg.style.transform=""
 chimg.style.transition=""
 })
 }

 //sleep函数
 function sleep (time) {
 return new Promise((resolve) => setTimeout(resolve, time));
 }


 //弹窗
 window.onload = function() {
 var om1 = document.getElementById("o1"); //o1是需要悬浮的选项，这里需要同步你的标签id或class名称
 var ob1 = document.getElementById("o2"); //o2是需要隐藏的div
 var om2 = document.getElementById("o3");
 var ob2 = document.getElementById("o4");
 var om3 = document.getElementById("o5");
 var ob3 = document.getElementById("o6");
 ob1.style.display = "none";
 ob1.onmouseover = om1.onmouseover = function(){
 ob1.style.display = "block";
 }
 ob1.onmouseout = om1.onmouseout = function(){
 ob1.style.display = "none";
 }

 ob2.style.display = "none";
 ob2.onmouseover = om2.onmouseover = function(){
 ob2.style.display = "block";
 }
 ob2.onmouseout = om2.onmouseout = function(){
 ob2.style.display = "none";
 }

 ob3.style.display = "none";
 ob3.onmouseover = om3.onmouseover = function(){
 ob3.style.display = "block";
 }
 ob3.onmouseout = om3.onmouseout = function(){
 ob3.style.display = "none";
 }
 }
&lt;/script>
&lt;/html></description></item></channel></rss>